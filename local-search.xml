<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1824. 最少侧跳次数</title>
    <link href="/shinone.github.io/2023/02/01/%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/"/>
    <url>/shinone.github.io/2023/02/01/%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p><p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p><p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。<br>这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p><p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。<br>这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p><p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：obstacles = [0,1,2,3,0]<br>输出：2 <br>解释：最优方案如上图箭头所示。总共有<span class="hljs-number"> 2 </span>次侧跳（红色箭头）。<br>注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点<span class="hljs-number"> 2 </span>处所示）。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-sideway-jumps/description/">https://leetcode.cn/problems/minimum-sideway-jumps/description/</a></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSideJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] obstacles)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        map[<span class="hljs-number">0</span>] = map[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; obstacles.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacles[i] &gt; <span class="hljs-number">0</span>) map[obstacles[i] - <span class="hljs-number">1</span>] = <span class="hljs-number">0x777fffff</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacles[i] - <span class="hljs-number">1</span> == j) <span class="hljs-keyword">continue</span>;<br>                map[j] = Math.min(map[j], Math.min(map[(j + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], map[(j + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>]) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(Math.min(map[<span class="hljs-number">0</span>], map[<span class="hljs-number">1</span>]), map[<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>799.香槟塔</title>
    <link href="/shinone.github.io/2022/11/21/%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/shinone.github.io/2022/11/21/%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。</p><p>示例 1:<br>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1<br>输出: 0.00000<br>解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</p><p>示例 2:<br>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1<br>输出: 0.50000<br>解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。<br>示例 3:</p><p>输入: poured = 100000009, query_row = 33, query_glass = 17<br>输出: 1.00000</p><p>提示:</p><p>0 &lt;= poured &lt;= 109<br>0 &lt;= query_glass &lt;= query_row &lt; 100</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>设dp[i][j]为层数i中，每一层第j个杯子<strong>所流淌过</strong>的香槟数量,每一次dp 如果当前杯子流淌的数量大于1，就向下一层累加<br>比如第一杯流了25瓶，那么第二层的两杯就分别是(25 - 1) / 2 = 12杯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-keyword">if</span> (query_row == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> poured &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">2</span>][query_row + <span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= query_row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> dp[i][j] &gt; <span class="hljs-number">1</span> ? ((dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) : <span class="hljs-number">0</span>;<br>                dp[i + <span class="hljs-number">1</span>][j] += add;<br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += add;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_row][query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>792.匹配子序列的单词数</title>
    <link href="/shinone.github.io/2022/11/18/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/shinone.github.io/2022/11/18/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><p>例如， “ace” 是 “abcde” 的子序列。</p><p>示例 1:</p><p>输入: s = “abcde”, words = [“a”,”bb”,”acd”,”ace”]<br>输出: 3<br>解释: 有三个是 s 的子序列的单词: “a”, “acd”, “ace”。<br>Example 2:</p><p>输入: s = “dsahjpjauf”, words = [“ahjpjau”,”ja”,”ahbwzgqnuk”,”tnmlanowax”]<br>输出: 2</p><p>提示:</p><p>1 &lt;= s.length &lt;= 5 * 104<br>1 &lt;= words.length &lt;= 5000<br>1 &lt;= words[i].length &lt;= 50<br>words[i]和 s 都只由小写字母组成。</p><h1 id="哈希-二分"><a href="#哈希-二分" class="headerlink" title="哈希+二分"></a>哈希+二分</h1><p>写完 自己测试一下 然后提交一次通过 爽到<br>传统做法是每个单词都去遍历一遍模板字符串，因为数据范围很大会超时，<br>每个单词的搜索又是避免不了的，只能优化查找的方法，跳过不必要的检索<br>于是对模板字符串做预处理，用一个哈希表列表去统计每个字母的下标列表<br>对每个待匹配单词，记录当前下标然后去查询列表中对应字母的下标，<br>最后这一步查找又可以用二分查找进一步优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        List&lt;Integer&gt;[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (map[index] == <span class="hljs-literal">null</span>) map[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            map[index].add(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        go:<br>        <span class="hljs-keyword">for</span> (String sub : words) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, len = sub.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                List&lt;Integer&gt; indexList = map[sub.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-keyword">if</span> (indexList == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span> go;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = indexList.size() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (index &lt; indexList.get(mid)) &#123;<br>                        r = mid;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        l = mid + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(indexList.get(r) &lt;= index) <span class="hljs-keyword">continue</span> go;<br>                index = indexList.get(r);<br>            &#125;<br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局倒置与局部倒置</title>
    <link href="/shinone.github.io/2022/11/16/%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
    <url>/shinone.github.io/2022/11/16/%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p><p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p><p>0 &lt;= i &lt; j &lt; n<br>nums[i] &gt; nums[j]<br>局部倒置 的数目等于满足下述条件的下标 i 的数目：</p><p>0 &lt;= i &lt; n - 1<br>nums[i] &gt; nums[i + 1]<br>当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：nums = [1,0,2]<br>输出：true<br>解释：有 1 个全局倒置，和 1 个局部倒置。<br>示例 2：</p><p>输入：nums = [1,2,0]<br>输出：false<br>解释：有 2 个全局倒置，和 1 个局部倒置。</p><p>提示：</p><p>n == nums.length<br>1 &lt;= n &lt;= 105<br>0 &lt;= nums[i] &lt; n<br>nums 中的所有整数 互不相同<br>nums 是范围 [0, n - 1] 内所有数字组成的一个排列</p><h1 id="最大前缀"><a href="#最大前缀" class="headerlink" title="最大前缀"></a>最大前缀</h1><p>局部倒置一定是全局倒置，如果找到一个不是局部倒置的全局倒置就可以直接返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[i] = Math.max(nums[i], nums[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; nums[i - <span class="hljs-number">2</span>] &gt; nums[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最大前缀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>790.多米诺和托米诺平铺</title>
    <link href="/shinone.github.io/2022/11/15/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/shinone.github.io/2022/11/15/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/2022111501.png" alt="多米诺和托米诺平铺"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>按图示一直推算，当i = n的值时，dp[i][3]就是当前列全覆盖的方案数量<br><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/2022111502.png" alt="多米诺和托米诺平铺"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">1</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>            dp[i][<span class="hljs-number">2</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>            dp[i][<span class="hljs-number">3</span>] = (((dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>791.自定义字符串排序</title>
    <link href="/shinone.github.io/2022/11/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <url>/shinone.github.io/2022/11/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>这题又写完才发现之前做过，丢人中等题，模拟一下就行了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。</p><p>对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。</p><p>返回 满足这个性质的 s 的任意排列 。</p><p>示例 1:</p><p>输入: order = “cba”, s = “abcd”<br>输出: “cbad”<br>解释:<br>“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。<br>因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。<br>示例 2:</p><p>输入: order = “cbafg”, s = “abcd”<br>输出: “cbad”</p><p><a href="https://leetcode.cn/problems/custom-sort-string/description/">https://leetcode.cn/problems/custom-sort-string/description/</a></p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>直接用数组统计词频重新构建string就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">customSortString</span><span class="hljs-params">(String order, String s)</span> &#123;<br>            <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : order.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (map[c - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map[c - <span class="hljs-string">&#x27;a&#x27;</span>]; i++) builder.append(c);<br>                    map[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (map[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; map[i]; j++) builder.append(<span class="hljs-string">&#x27;a&#x27;</span> + j);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> builder.toString();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>864. 获取所有钥匙的最短路径</title>
    <link href="/shinone.github.io/2022/11/11/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/shinone.github.io/2022/11/11/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二维网格 grid ，其中：</p><p>‘.’ 代表一个空房间<br>‘#’ 代表一堵<br>‘@’ 是起点<br>小写字母代表钥匙<br>大写字母代表锁<br>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足 1 &lt;= k &lt;= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例 1：</p><p>输入：grid = [“@.a.#”,”###.#”,”b.A.B”]<br>输出：8<br>解释：目标是获得所有钥匙，而不是打开所有锁。</p><p>示例 2：</p><p>输入：grid = [“@..aA”,”..B#.”,”….b”]<br>输出：6</p><p>示例 3:<br>输入: grid = [“@Aa”]<br>输出: -1</p><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>首先，可能会重复走过同一个格子，如[“cBa..AbC”]<br>但是可以确定，再算上当前所收获的钥匙的状态的时候，每一个格子所需的最短路径是确认的，<br>可能直接拿到钥匙a，需要10步，直接拿到钥匙b需要2步，同时拿到钥匙ab，就会产生两个分支，先拿a和先拿b，<br>每一个状态在每一个格子只会通过一次<br>于是基于上面的分析，DFS是行不通的，DFS找到一个答案后不会直接返回，而是找到所有答案后才去选择最小值，状态数量直接爆炸，<br>因为要计算最小步数，所以BFS网状扩散搜索，到达第一个答案就可以直接返回</p><p>实在没时间自己写了，搬运三叶姐的代码加上注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">35</span>, K = <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">// 记录到达某个状态的最小步数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N][<span class="hljs-number">1</span> &lt;&lt; K];<br>    <span class="hljs-comment">// 四个方向</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length, m = g[<span class="hljs-number">0</span>].length(), cnt = <span class="hljs-number">0</span>;<br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                Arrays.fill(dist[i][j], INF);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[i].charAt(j);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br>                    d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;);<br>                    dist[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!d.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] info = d.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>], y = info[<span class="hljs-number">1</span>], cur = info[<span class="hljs-number">2</span>], step = dist[x][y][cur];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] di : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + di[<span class="hljs-number">0</span>], ny = y + di[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 如果下一步超出范围 就跳过</span><br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[nx].charAt(ny);<br>                <span class="hljs-comment">// 如果下一步撞墙 就跳过</span><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 如果下一步是锁但是没有钥匙 就跳过</span><br>                <span class="hljs-keyword">if</span> ((c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="hljs-string">&#x27;A&#x27;</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ncur</span> <span class="hljs-operator">=</span> cur;<br>                <span class="hljs-comment">// 如果下一步是钥匙捡起来</span><br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ncur |= <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>                <span class="hljs-comment">// 捡起来之后正确了就直接返回</span><br>                <span class="hljs-keyword">if</span> (ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果下一个状态用了更少的步数就跳过</span><br>                <span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &gt;= dist[nx][ny][ncur]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 记录到达当前状态用了多少步</span><br>                dist[nx][ny][ncur] = step + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 入队尾继续BFS</span><br>                d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny, ncur&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>广度优先搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>764.最大加号标志</title>
    <link href="/shinone.github.io/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/"/>
    <url>/shinone.github.io/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>用0、1、2、3 表示从上下左右四个方向，统计连续的1的数量，<br>最后统计 每一个格子 四个方向里 连续1的最小个数 中的最大值<br>时间复杂度O(n²)<br><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/2022110901.png" alt="最大加号标志"></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>901.股票价格跨度</title>
    <link href="/shinone.github.io/2022/10/21/%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/"/>
    <url>/shinone.github.io/2022/10/21/%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>示例：</p><p>输入：[“StockSpanner”,”next”,”next”,”next”,”next”,”next”,”next”,”next”], [[],[100],[80],[60],[70],[60],[75],[85]]<br>输出：[null,1,1,1,2,1,4,6]<br>解释：<br>首先，初始化 S = StockSpanner()，然后：<br>S.next(100) 被调用并返回 1，<br>S.next(80) 被调用并返回 1，<br>S.next(60) 被调用并返回 1，<br>S.next(70) 被调用并返回 2，<br>S.next(60) 被调用并返回 1，<br>S.next(75) 被调用并返回 4，<br>S.next(85) 被调用并返回 6。</p><p>注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格<br>(包括今天的价格 75) 小于或等于今天的价格。</p><p>提示：</p><p>调用 StockSpanner.next(int price) 时，将有 1 &lt;= price &lt;= 10^5。<br>每个测试用例最多可以调用  10000 次 StockSpanner.next。<br>在所有测试用例中，最多调用 150000 次 StockSpanner.next。<br>此问题的总时间限制减少了 50%。</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>很明显如果维护一个列表每次都去遍历会超时，第一反应单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;<span class="hljs-type">int</span>[]&gt; deque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek()[<span class="hljs-number">0</span>] &gt; price) &#123;<br>            deque.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price, <span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peek()[<span class="hljs-number">0</span>] &lt;= price) &#123;<br>            count += deque.pop()[<span class="hljs-number">1</span>];<br>        &#125;<br>        deque.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price, count&#125;);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最多能完成排序的块</title>
    <link href="/shinone.github.io/2022/10/13/%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/"/>
    <url>/shinone.github.io/2022/10/13/%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>好久（大概一个月不到）没做题了，这题这么简单怎么我就脑子秀逗没转过来呢….</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。</p><p>我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p><p>返回数组能分成的最多块数量。</p><p>示例 1:</p><p>输入: arr = [4,3,2,1,0]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。<br>示例 2:</p><p>输入: arr = [1,0,2,3,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。<br>然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</p><p>提示:</p><p>n == arr.length<br>1 &lt;= n &lt;= 10<br>0 &lt;= arr[i] &lt; n<br>arr 中每个元素都 不同</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>因为数组元素固定是从0到n - 1，<br>直接对下标和数组元素分别累加，只要值相同就代表可以分块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">vSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">iSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            vSum += arr[i];<br>            iSum += i;<br>            <span class="hljs-keyword">if</span>(vSum == iSum)ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>670.最大交换</title>
    <link href="/shinone.github.io/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/"/>
    <url>/shinone.github.io/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>时隔N久的更新，其实题一直都有在做，但是完全不想整理下来，而且最近基本都是简单题啊，二叉树啊，二叉树属于是玩烂了，不想写了…<br>今天这题有在面试里被问过简单版本的</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。</p><p>示例 1 :</p><p>输入: 2736<br>输出: 7236<br>解释: 交换数字2和数字7。<br>示例 2 :</p><p>输入: 9973<br>输出: 9973<br>解释: 不需要交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-swap">https://leetcode.cn/problems/maximum-swap</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>从最高位向后依次寻找，找到比最高位最大的，排在最后面的那个数字，然后交换，结束<br>为啥要最后面，用例：21997，91297和91927，肯定是后面这个更大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">char</span>[] number = String.valueOf(num).toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = number.length;<br>        <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, maxIndex = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; len) &#123;<br>                <span class="hljs-keyword">if</span> (number[i] &lt; number[j]) <br>                    maxIndex = maxIndex &lt; <span class="hljs-number">0</span> ? j : number[maxIndex] &lt;= number[j] ? j : maxIndex;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxIndex &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> number[i];<br>                number[i] = number[maxIndex];<br>                number[maxIndex] = c;<br>                <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(number));<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绘画20220906</title>
    <link href="/shinone.github.io/2022/09/06/%E7%BB%98%E7%94%BB20220906/"/>
    <url>/shinone.github.io/2022/09/06/%E7%BB%98%E7%94%BB20220906/</url>
    
    <content type="html"><![CDATA[<blockquote><p>自己跟了一些课，总的下来感觉k大的课真的脉络很清晰<br>基于自己学习情况总结了一下学习方向和大纲</p></blockquote><p>1、透视是基本定理，首先要确保透视关系正确<br>2、并不是说用类似厚涂和色块的方式上色就可以不追求线稿的详细程度，用堆画面信息量的方式可能看上去还不错是因为焦点部分没有太大的结构问题，<br>看大佬作画打一个不精细的线稿然后直接上色或者一边上色一边就开始二分闭塞是因为大佬前面的部分已经很熟悉了，可以保证结构和形状基本不出问题，<br>初学练习线稿是练习结构的正确性，练习速写和色块是练习形状的设计<br>3、在色彩上可以区分为物理基础和画面表现力，画面表现力又可以分为细节(信息量)和形状，适当得违反物理准则提升画面表现力是ok的<br>4、传统上色流程:线稿-&gt;闭塞-&gt;固有色-&gt;固有色的微妙差距-&gt;环境光-&gt;直射光-&gt;透光-&gt;天光-&gt;漫反射-&gt;细节修改-&gt;光晕<br>5、AO画法：线稿-&gt;闭塞-&gt;二分-&gt;反推明度-&gt;固有色-&gt;块面细节-&gt;环境光-&gt;直射光-&gt;透光-&gt;天光-&gt;漫反射-&gt;细节修改-&gt;光晕<br>7、藏色的基本是向读者透露更多的信息，但是不能违反素描关系<br>8、不同的固有色纯度的变化和明度变化的正比关系是不同的，这是藏色能够实现的基本原因<br>6、完形理论：一条直线中间隐藏掉部分不会影响想要表现的讯息，比如投影应该是锐利的，中间可以模糊成三级边，虽然违反了物理准则，但是增强了信息量和表现力，但是需要控制度不要过度表现质感影响到形状<br>比如不要把一整块暗部或者亮部完全封死，可以把内外亮暗部连接起来，虽然违反了二分但是会有更透气的感觉<br>7、不同风格不同形式其实都是基于基本理论的不同拼凑方式，不是每一种处理方式全都要揉进去，根据自己不同的组合方式解释自己的绘画语言</p><p>所以还是得循序渐进，<br>如果说一张画的完成，形状结构占了60%色彩光影占了30%细节等等占10%，<br>及格分数是60分，<br>可以形状没那么及格，靠色彩和细节拯救一下，但是如果形状结构全崩了是救不回来的</p><p>所以学完色彩之后还是得安心回头好好练线稿啊(</p>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
      <category>大纲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>768. 最多能完成排序的块II</title>
    <link href="/shinone.github.io/2022/08/13/%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97II/"/>
    <url>/shinone.github.io/2022/08/13/%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97II/</url>
    
    <content type="html"><![CDATA[<p>时隔许久 困难难度 值得一更</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。</p><p>arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><p>示例 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[5,4,3,2,1]</span><br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 <span class="hljs-comment">[5, 4]</span>, <span class="hljs-comment">[3, 2, 1]</span> 的结果是 <span class="hljs-comment">[4, 5, 1, 2, 3]</span>，这不是有序的数组。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[2,1,3,4,4]</span><br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 <span class="hljs-comment">[2, 1]</span>, <span class="hljs-comment">[3, 4, 4]</span>。<br>然而，分成 <span class="hljs-comment">[2, 1]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[4]</span>, <span class="hljs-comment">[4]</span> 可以得到最多的块数。<br></code></pre></td></tr></table></figure><p>注意:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>的长度在[<span class="hljs-number">1</span>, <span class="hljs-number">2000</span>]之间。<br><span class="hljs-attribute">arr</span>[i]的大小在[<span class="hljs-number">0</span>, <span class="hljs-number">10</span>**<span class="hljs-number">8</span>]之间。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii">https://leetcode.cn/problems/max-chunks-to-make-sorted-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="前缀和1-带排序"><a href="#前缀和1-带排序" class="headerlink" title="前缀和1 带排序"></a>前缀和1 带排序</h1><p>直接对数组克隆 并且排个序，分别把两个数组的前面的数字加起来，如果值相等 就能分块，<br>因为有排序 时间复杂度是O(nlogn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span>[] clone = arr.clone();<br>        Arrays.sort(clone);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; clone.length; i++) &#123;<br>            sum1 += arr[i];<br>            sum2 += clone[i];<br>            <span class="hljs-keyword">if</span> (sum1 == sum2) count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和2-不排序"><a href="#前缀和2-不排序" class="headerlink" title="前缀和2 不排序"></a>前缀和2 不排序</h1><p>维护两个数组，一个数组是从左边开始最大的元素，一个是右边最小的元素<br>如果左边最大的元素比右边最小的元素小，就可以分块<br>因为只用了三次遍历，时间复杂度是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[] maxOfLeft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] minOfRight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        maxOfLeft[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            maxOfLeft[i] = Math.max(maxOfLeft[i - <span class="hljs-number">1</span>], arr[i]);<br>        &#125;<br>        minOfRight[n - <span class="hljs-number">1</span>] = arr[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minOfRight[i] = Math.min(minOfRight[i + <span class="hljs-number">1</span>], arr[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (maxOfLeft[i] &lt;= minOfRight[i + <span class="hljs-number">1</span>]) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>在上一步的基础上引入单调栈，省去了两次遍历统计数组的操作，同样是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty() || num &gt;= stack.peek()) &#123;<br>                stack.push(num);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; num) &#123;<br>                    stack.pop();<br>                &#125;<br>                stack.push(mx);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>899. 有序队列</title>
    <link href="/shinone.github.io/2022/08/04/%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    <url>/shinone.github.io/2022/08/04/%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最小表示法：不断地把字符串的首字符放到末尾,找出其中最小的一个字符串</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。</p><p>返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。</p><p>示例 1：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：s = <span class="hljs-string">&quot;cba&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;acb&quot;</span><br>解释：<br>在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “<span class="hljs-keyword">bac”。</span><br><span class="hljs-keyword"></span>在第二步中，我们将第一个字符（“<span class="hljs-keyword">b”）移动到最后，获得最终结果 </span>“acb”。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;baaca&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;aaabc&quot;</span><br>解释：<br>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。<br>在第二步中，我们将第三个字符（“<span class="hljs-keyword">c</span>”）移动到最后，获得最终结果 “aaabc”。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> k &lt;<span class="hljs-operator">=</span> S.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">1000</span><br>s 只由小写字母组成。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/orderly-queue">https://leetcode.cn/problems/orderly-queue</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h1><p>当K &gt; 1 的时候，我们可以把字符串任意顺序排序，只需要对字符串做一次排序就行<br>k = 1 的时候就循环每一种情况找到最小值返回就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">orderlyQueue</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>            Arrays.sort(chars);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        &#125;<br>        <span class="hljs-comment">// 等于1的情况，循环检查，找出最小串开始的位置</span><br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; chars.length; i++) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.compare(chars, i, min)) min = i;<br>        <span class="hljs-comment">// 从最小串开始的位置构建字符串</span><br>        <span class="hljs-type">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[chars.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) res[i] = chars[min++ % chars.length];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res);<br>    &#125;<br>    <span class="hljs-comment">// 对比从c开始的字符串是否比从d开始的字符串小</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a[c % a.length] &lt; a[d % a.length]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (a[c++ % a.length] &gt; a[d++ % a.length]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>752.打开转盘锁</title>
    <link href="/shinone.github.io/2022/07/30/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/shinone.github.io/2022/07/30/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><p>示例 1:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：deadends = [<span class="hljs-string">&quot;0201&quot;</span>,<span class="hljs-string">&quot;0101&quot;</span>,<span class="hljs-string">&quot;0102&quot;</span>,<span class="hljs-string">&quot;1212&quot;</span>,<span class="hljs-string">&quot;2002&quot;</span>], target = <span class="hljs-string">&quot;0202&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<br>可能的移动序列为 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;1000&quot;</span> -&gt; <span class="hljs-string">&quot;1100&quot;</span> -&gt; <span class="hljs-string">&quot;1200&quot;</span> -&gt; <span class="hljs-string">&quot;1201&quot;</span> -&gt; <span class="hljs-string">&quot;1202&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span>。<br>注意 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0001&quot;</span> -&gt; <span class="hljs-string">&quot;0002&quot;</span> -&gt; <span class="hljs-string">&quot;0102&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span> 这样的序列是不能解锁的，<br>因为当拨动到 <span class="hljs-string">&quot;0102&quot;</span> 时这个锁就会被锁定。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/open-the-lock">https://leetcode.cn/problems/open-the-lock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A*算法是一种启发式搜索算法，基于迪杰斯特拉算法和最有优先搜索算法的改进版本<br>核心思想是维护一个优先队列和一个死亡队列，优先队列根据f(x) = h(x) + g(x)对节点进行优先值排序，<br>也就是到这一步需要多少步 加上 到终点预计需要多少值，这里的h()就是启发式函数</p><p>我是想自己写的，写出来一个版本在改bug的时候，突然忙了起来 一周过后看着自己写的代码，陷入沉思…嗯 随便拉一个过来加注释吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        String str;<br>        <span class="hljs-type">int</span> val, step;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        *  str : 对应字符串</span><br><span class="hljs-comment">        *  val : 估值（与目标字符串 target 的最小转换成本）</span><br><span class="hljs-comment">        *  step: 对应字符串是经过多少步转换而来</span><br><span class="hljs-comment">        */</span><br>        Node(String _str, <span class="hljs-type">int</span> _val, <span class="hljs-type">int</span> _step) &#123;<br>            str = _str;<br>            val = _val;<br>            step = _step;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启发式函数，当前字符串距离目标字符串还需要多少步</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> str.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>, target = t.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.min(cur, target), b = Math.max(cur, target);<br>            <span class="hljs-comment">// 在「正向转」和「反向转」之间取 min</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(b - a, a + <span class="hljs-number">10</span> - b);<br>            ans += min;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    String s, t;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] ds, String _t)</span> &#123;<br>        s = <span class="hljs-string">&quot;0000&quot;</span>;<br>        t = _t;<br>        <span class="hljs-keyword">if</span> (s.equals(t)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String d : ds) set.add(d);<br>        <span class="hljs-keyword">if</span> (set.contains(s)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 优先搜索队列</span><br>        PriorityQueue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);<br>        <span class="hljs-comment">// 用于记录是否被更新最短步长的map</span><br>        Map&lt;String, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化头结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(s, f(s), <span class="hljs-number">0</span>);<br>        q.add(root);<br>        map.put(s, root);<br>        <span class="hljs-comment">// 开搜</span><br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-type">char</span>[] pcs = poll.str.toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> poll.step;<br>            <span class="hljs-keyword">if</span> (poll.str.equals(t)) <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pcs[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> (cur + j) % <span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>) next = <span class="hljs-number">9</span>;<br>                    <br>                    <span class="hljs-type">char</span>[] clone = pcs.clone();<br>                    clone[i] = (<span class="hljs-type">char</span>)(next + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(clone);<br><br>                    <span class="hljs-keyword">if</span> (set.contains(str)) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 如果 str 还没搜索过，或者 str 的「最短距离」被更新，则入队</span><br>                    <span class="hljs-keyword">if</span> (!map.containsKey(str) || map.get(str).step &gt; step + <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(str, step + <span class="hljs-number">1</span> + f(str), step + <span class="hljs-number">1</span>);<br>                        map.put(str, node);<br>                        q.add(node);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>919. 完全二叉树插入器</title>
    <link href="/shinone.github.io/2022/07/25/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/"/>
    <url>/shinone.github.io/2022/07/25/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/20220725.png" alt="完全二叉树插入器"></p><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>其实只要类内部维护一个队列，按层序依次插入就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br>    TreeNode root;<br>    Deque&lt;TreeNode&gt; deque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CBTInserter</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.root = root;<br>        deque.addLast(root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-keyword">if</span> (first.left == <span class="hljs-literal">null</span>) &#123;<br>                first.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                deque.addFirst(first);<br>                <span class="hljs-keyword">return</span> first.val;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (first.right == <span class="hljs-literal">null</span>) &#123;<br>                first.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>                deque.addLast(first.left);<br>                deque.addLast(first.right);<br>                <span class="hljs-keyword">return</span> first.val;<br>            &#125;<br>            deque.addLast(first.left);<br>            deque.addLast(first.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">get_root</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/shinone.github.io/2022/07/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/shinone.github.io/2022/07/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>当对象间关系存在一对多关系的时候，一个对象的状态变化需要通知到所有依赖它的对象。<br>解决方案是在对象中添加一个列表，将所有依赖它的对象注册到列表中，当发生变化时依次去通知这些对象<br>即观察者依赖于被观察者<br>被观察者不关心他需要通知谁，由观察者获取对象，将自己注册到列表中去。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>假设有一个时间中心会不定期更新时间，而一旦时间中心更新了时间，就要同步到分布在其他地方的中心一同更新时间<br>java中已经有实现代码，可以通过继承和实现接口简单实现观察者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeObservable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Timestamp time;<br><br>    TimeObservable() &#123;<br>        <span class="hljs-built_in">this</span>.time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis());<br>    &#125;<br>    <span class="hljs-comment">// 设置时间</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTime</span><span class="hljs-params">(Timestamp time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.time = time;<br>        <span class="hljs-comment">// 通知所有观察者</span><br>        <span class="hljs-built_in">this</span>.setChanged();<br>        <span class="hljs-built_in">this</span>.notifyObservers();<br>    &#125;<br>    <br>    Timestamp <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.time;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 观察者1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kunming</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">private</span> Timestamp time;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Observable o, Object arg)</span> &#123;<br>    <span class="hljs-type">TimeObservable</span> <span class="hljs-variable">timeObservable</span> <span class="hljs-operator">=</span> (TimeObservable) o;<br>    <span class="hljs-built_in">this</span>.time = timeObservable.getTime();<br>    System.out.println(<span class="hljs-string">&quot;昆明更新时间成功:&quot;</span> + time.getTime());<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 观察者2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Beijing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">private</span> Timestamp time;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Observable o, Object arg)</span> &#123;<br>    <span class="hljs-type">TimeObservable</span> <span class="hljs-variable">timeObservable</span> <span class="hljs-operator">=</span> (TimeObservable) o;<br>    <span class="hljs-built_in">this</span>.time = timeObservable.getTime();<br>    System.out.println(<span class="hljs-string">&quot;北京更新时间成功:&quot;</span> + time.getTime());<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 观察者3</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shanghai</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">private</span> Timestamp time;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Observable o, Object arg)</span> &#123;<br>    <span class="hljs-type">TimeObservable</span> <span class="hljs-variable">timeObservable</span> <span class="hljs-operator">=</span> (TimeObservable) o;<br>    <span class="hljs-built_in">this</span>.time = timeObservable.getTime();<br>    System.out.println(<span class="hljs-string">&quot;上海更新时间成功:&quot;</span> + time.getTime());<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 测试方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">TimeObservable</span> <span class="hljs-variable">observable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeObservable</span>();<br>    System.out.println(<span class="hljs-string">&quot;第一次更新，没有观察者&quot;</span>);<br>    observable.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));<br>    System.out.println(<span class="hljs-string">&quot;第二次更新&quot;</span>);<br>    observable.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Kunming</span>());<br>    observable.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Shanghai</span>());<br>    observable.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));<br>    System.out.println(<span class="hljs-string">&quot;第三次更新&quot;</span>);<br>    observable.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Beijing</span>());<br>    observable.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事件分发模式"><a href="#事件分发模式" class="headerlink" title="事件分发模式"></a>事件分发模式</h1><p>我们也可以基于观察者模式实现一串调用链，A-&gt;B-&gt;C-&gt;…<br>但是这样代码会变得相当复杂，可以再抽象一个事件系统出来，<br>被观察者只负责发送事件到事件系统，而观察者可以同时观察很多个不同的事件，<br>由事件系统去完成接收事件和事件的分发等操作，由此进行解耦</p><h1 id="时间解耦"><a href="#时间解耦" class="headerlink" title="时间解耦"></a>时间解耦</h1><p>由于观察者模式是同步操作，需要在全部通知完之后才能返回。<br>也就是消息队列的发布-订阅模式，将消息丢进消息队列就可以直接返回，再由订阅者们对消息进行消费</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>731. 我的日程安排表 II</title>
    <link href="/shinone.github.io/2022/07/19/%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8II/"/>
    <url>/shinone.github.io/2022/07/19/%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<p>正常思考就是造一个数组，每次新增就+1，问题是数据范围是1e9，空间不够，<br>然后再进一步用list&lt;int[]&gt; 装数组，每次新增都去遍历统计，但是时间复杂度很高，而且空间用的还是很多<br>再优化一步，可以用treemap作为差分数组储存，空间就小了很多，但是还是要每次都遍历,<br>最优解法是线段树。</p><p>我自己只能做到差分数组那一步，线段树就是纯学习了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;= x &lt; end。</p><p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p><p>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p> </p><p>示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MyCalendar()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">50</span>, <span class="hljs-number">60</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>); <span class="hljs-comment">// returns false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">25</span>, <span class="hljs-number">55</span>); <span class="hljs-comment">// returns true</span><br>解释：<br>前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。<br>第四个日程安排活动（<span class="hljs-number">5</span>,<span class="hljs-number">15</span>）不能添加至日历中，因为它会导致三重预订。<br>第五个日程安排（<span class="hljs-number">5</span>,<span class="hljs-number">10</span>）可以添加至日历中，因为它未使用已经双重预订的时间<span class="hljs-number">10</span>。<br>第六个日程安排（<span class="hljs-number">25</span>,<span class="hljs-number">55</span>）可以添加至日历中，因为时间 <span class="hljs-literal">[<span class="hljs-number">25</span>,<span class="hljs-number">40</span>]</span> 将和第三个日程安排双重预订；<br>时间 <span class="hljs-literal">[<span class="hljs-number">40</span>,<span class="hljs-number">50</span>]</span> 将单独预订，时间 <span class="hljs-literal">[<span class="hljs-number">50</span>,<span class="hljs-number">55</span>）将和第二个日程安排双重预订。</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/my-calendar-ii">https://leetcode.cn/problems/my-calendar-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarTwo</span> &#123;<br>    TreeMap&lt;Integer, Integer&gt; cnt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarTwo</span><span class="hljs-params">()</span> &#123;<br>        cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer, Integer&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxBook</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        cnt.put(start, cnt.getOrDefault(start, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        cnt.put(end, cnt.getOrDefault(end, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> entry.getValue();<br>            maxBook += freq;<br>            <span class="hljs-keyword">if</span> (maxBook &gt; <span class="hljs-number">2</span>) &#123;<br>                cnt.put(start, cnt.getOrDefault(start, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                cnt.put(end, cnt.getOrDefault(end, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarTwo</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        节点类</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>            <span class="hljs-type">int</span> ls, rs, add, max;   <span class="hljs-comment">// ls, rs 为左右子节点在tr中索引(触手); add 懒标记; max 维护区间最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>, M = <span class="hljs-number">120010</span>, cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// N 区间范围; M 节点个数; cnt 节点在tr中的索引</span><br>        Node[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[M];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarTwo</span><span class="hljs-params">()</span> &#123;<br>            tr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">// 创建根节点</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        更新区间[l,r] 值为val</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-comment">// [l,r]完全覆盖了u表示的区间</span><br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) &#123;<br>                tr[u].add += val;   <span class="hljs-comment">// 懒标记要累计(例如覆盖了2次)</span><br>                <span class="hljs-comment">// 最大值是max(curVal,curVal+val)=curVal+val -&gt; max += val;</span><br>                tr[u].max += val;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束</span><br>            &#125;<br>            <span class="hljs-comment">// 否则</span><br>            lazyCreate(u);  <span class="hljs-comment">// 动态开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) update(tr[u].ls, lc, mid, l, r, val); <span class="hljs-comment">// 尝试更新左子树</span><br>            <span class="hljs-keyword">if</span> (r &gt; mid) update(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r, val);  <span class="hljs-comment">// 尝试更新右子树</span><br>            pushUp(u);  <span class="hljs-comment">// 回溯最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">       查询区间[l,r]的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) <span class="hljs-keyword">return</span> tr[u].max;<br>            lazyCreate(u);  <span class="hljs-comment">// 冬天开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>, res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) res = query(tr[u].ls, lc, mid, l, r);<br>            <span class="hljs-keyword">if</span> (r &gt; mid) res = Math.max(res, query(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r));   <span class="hljs-comment">// 记得取左右子节点的最大值</span><br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        按需动态开点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-keyword">if</span> (tr[u].ls == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 左子节点不存在 -&gt; 创建并构建连接</span><br>                tr[u].ls = cnt++;<br>                tr[tr[u].ls] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tr[u].rs == <span class="hljs-number">0</span>) &#123;<br>                tr[u].rs = cnt++;<br>                tr[tr[u].rs] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        下传懒标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> tr[u].add;  <span class="hljs-comment">// 节点u下传下来的懒标记</span><br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 当且仅当懒标记不为0才进行下传</span><br>                <span class="hljs-comment">// 下传懒标记至子节点(累计)</span><br>                tr[tr[u].ls].add += v;<br>                tr[tr[u].rs].add += v;<br>                <span class="hljs-comment">// 更新左右子节点的值(累计)</span><br>                tr[tr[u].ls].max += v;<br>                tr[tr[u].rs].max += v;<br>                tr[u].add = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 下传懒标记完成撤销u的懒标记</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        回溯更新u的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            tr[u].max = Math.max(tr[tr[u].ls].max, tr[tr[u].rs].max);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>            <span class="hljs-comment">// 最大值&gt;=2说明区间[start,end-1]存在某个点覆盖了2次</span><br>            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            update(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>线段树辅助理解，假设现在范围是0到10，向其中插入4到9，每个数字分别 + 1<br><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/20220719.png" alt="线段树插入"></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/shinone.github.io/2022/07/18/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/shinone.github.io/2022/07/18/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>一句话描述：适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>系统只能调用A接口，但是现在期望A接口要兼容B接口的功能的时候</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>系统以前只通过mysqlDriver接口连接数据库，但是现在要额外去连接新的数据库，而且新的接口已经开发好了。<br>但是因为大量使用了以前的接口，不好修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 老接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">mysqlDriver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span>;<br>&#125;<br><span class="hljs-comment">// 新接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">newDriver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span>;<br>&#125;<br><span class="hljs-comment">// 新接口的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">oracleDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">newDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 新接口的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">postgresqlDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">newDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newDriverAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">mysqlDriver</span>&#123;<br>    newDriver newDriver;<br>    newDriverAdapter(String dbName) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;postgresql&quot;</span>.equals(dbName)) &#123;<br>            newDriver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">postgresqlDriverImpl</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;oracle&quot;</span>.equals(dbName)) &#123;<br>            newDriver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">oracleDriverImpl</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;postgresql&quot;</span>.equals(dbName)) &#123;<br>            newDriver.connectPostgresql(dbName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;oracle&quot;</span>.equals(dbName)) &#123;<br>            newDriver.connectOracle(dbName);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 修改老接口的实现类,调用适配器完成工作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mysqlDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">mysqlDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;mysql&quot;</span>.equals(dbName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">newDriverAdapter</span> <span class="hljs-variable">newDriverAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">newDriverAdapter</span>(dbName);<br>            newDriverAdapter.connect(dbName);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">mysqlDriverImpl</span> <span class="hljs-variable">mysqlDriver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">mysqlDriverImpl</span>();<br>        mysqlDriver.connect(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        mysqlDriver.connect(<span class="hljs-string">&quot;oracle&quot;</span>);<br>        mysqlDriver.connect(<span class="hljs-string">&quot;postgresql&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//        connect to mysql </span><br><span class="hljs-comment">//        connect to oracle</span><br><span class="hljs-comment">//        connect to postgresql</span><br></code></pre></td></tr></table></figure><p>以上就达到了完全不需要更改使用到老接口的位置，只需要在实现类中新增适配器的调用就能达到目标</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>不能过多使用，否则整个系统看上去就很乱，后续开发也会很麻烦</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>适配器模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>749. 隔离病毒</title>
    <link href="/shinone.github.io/2022/07/18/%E9%9A%94%E7%A6%BB%E7%97%85%E6%AF%92/"/>
    <url>/shinone.github.io/2022/07/18/%E9%9A%94%E7%A6%BB%E7%97%85%E6%AF%92/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/20220718.jpg" alt="749. 隔离病毒"><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/contain-virus">https://leetcode.cn/problems/contain-virus</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><p>核心思想：<br>1、找出威胁最大的一群病毒，并统计挡板数量<br>2、最大的那群全部隔离，置为-1<br>3、剩下的病毒全部扩散一次<br>然后重复这个步骤直到结束</p><p>难吧，也没多难…就是是真的很费时间啊</p><p>可以把mark的方法再抽取出来，还有mark数组可以优化成全部公用一个boolean数组，等等，懒得优化代码了XD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] direction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> g;<br>    <span class="hljs-type">int</span>[][] markD;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">containVirus</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> isInfected[<span class="hljs-number">0</span>].length, y = isInfected.length;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">3</span>] - a[<span class="hljs-number">3</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; y; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; x; j++) &#123;<br>                <span class="hljs-comment">// 递归查找标记扩散区域，并记录病毒入口</span><br>                <span class="hljs-keyword">if</span> (isInfected[i][j] == <span class="hljs-number">1</span> &amp;&amp; mark[i][j] != <span class="hljs-number">1</span>) &#123;<br>                    g = <span class="hljs-number">0</span>;<br>                    markD = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mark(isInfected, mark, i, j);<br>                    <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)&#123;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;count, i, j, g&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最大的设墙，其余的扩散</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] first = queue.poll();<br>            result += first[<span class="hljs-number">0</span>];<br>            surround(isInfected, first[<span class="hljs-number">1</span>], first[<span class="hljs-number">2</span>]);<br>            <span class="hljs-type">int</span>[][] mark1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span>[] poll = queue.poll();<br>                <span class="hljs-comment">// 扩散</span><br>                diffusion(isInfected, mark1, poll[<span class="hljs-number">1</span>], poll[<span class="hljs-number">2</span>]);<br>            &#125;<br><br>            <span class="hljs-comment">// 扩散完再确定一次病毒区域</span><br>            <span class="hljs-type">int</span>[][] mark2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; y; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; x; j++) &#123;<br>                    <span class="hljs-comment">// 递归查找标记扩散区域，并记录病毒入口</span><br>                    <span class="hljs-keyword">if</span> (isInfected[i][j] == <span class="hljs-number">1</span> &amp;&amp; mark2[i][j] != <span class="hljs-number">1</span>) &#123;<br>                        g = <span class="hljs-number">0</span>;<br>                        markD = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mark(isInfected, mark2, i, j);<br>                        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)&#123;<br>                            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;count, i, j, g&#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span>[][] mark, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        mark[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (markD[ci][cj] == <span class="hljs-number">0</span>) g++;<br>                markD[ci][cj] = <span class="hljs-number">1</span>;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span> &amp;&amp; mark[ci][cj] != <span class="hljs-number">1</span>) &#123;<br>                count += mark(isInfected, mark, ci, cj);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//扩散</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">diffusion</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span>[][] mark, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        mark[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">0</span>) &#123;<br>                mark[ci][cj] = <span class="hljs-number">1</span>;<br>                isInfected[ci][cj] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span> &amp;&amp; mark[ci][cj] != <span class="hljs-number">1</span>) &#123;<br>                diffusion(isInfected, mark, ci, cj);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设为-1</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">surround</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span>) &#123;<br>                isInfected[ci][cj] = -<span class="hljs-number">1</span>;<br>                surround(isInfected, ci, cj);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>735. 行星碰撞</title>
    <link href="/shinone.github.io/2022/07/13/%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/"/>
    <url>/shinone.github.io/2022/07/13/%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 asteroids，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p> </p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：asteroids = [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下<span class="hljs-number"> 10 </span>。<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 10 </span>永远不会发生碰撞。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：asteroids = <span class="hljs-comment">[8,-8]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：8 和 -8 碰撞后，两者都发生爆炸。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：asteroids = [10,2,<span class="hljs-string">-5</span>]<br>输出：[10]<br>解释：2 和 <span class="hljs-string">-5</span> 发生碰撞后剩下 <span class="hljs-string">-5</span> 。10 和 <span class="hljs-string">-5</span> 发生碰撞后剩下 10 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/asteroid-collision">https://leetcode.cn/problems/asteroid-collision</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>简单的栈模拟题，写出来很简单，在怎么把代码变短上多花了点时间(乐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        out:<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> asteroid : asteroids) &#123;<br>            <span class="hljs-keyword">if</span> (asteroid &gt; <span class="hljs-number">0</span>) &#123;<br>                deque.addLast(asteroid);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekLast() &lt;= -asteroid) &#123;<br>                <span class="hljs-keyword">if</span> (deque.pollLast() == -asteroid) <span class="hljs-keyword">continue</span> out;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peekLast() &lt; <span class="hljs-number">0</span>) deque.addLast(asteroid);<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[deque.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty()) result[i++] = deque.pollFirst();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>早上出门时心情真的很好，但自</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>741. 摘樱桃</title>
    <link href="/shinone.github.io/2022/07/12/%E6%91%98%E6%A8%B1%E6%A1%83/"/>
    <url>/shinone.github.io/2022/07/12/%E6%91%98%E6%A8%B1%E6%A1%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p><p>0 表示这个格子是空的，所以你可以穿过它。<br>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。<br>-1 表示这个格子里有荆棘，挡着你的路。<br>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p><p>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；<br>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；<br>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；<br>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">示例 <span class="hljs-number">1</span>:<br><br>输入: grid =<br><span class="hljs-string">[[0, 1, -1],</span><br><span class="hljs-string">[1, 0, -1],</span><br><span class="hljs-string">[1, 1,  1]]</span><br>输出: <span class="hljs-number">5</span><br>解释：<br>玩家从（<span class="hljs-number">0</span>,<span class="hljs-number">0</span>）点出发，经过了向下走，向下走，向右走，向右走，到达了点(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)。<br>在这趟单程中，总共摘到了<span class="hljs-number">4</span>颗樱桃，矩阵变成了<span class="hljs-string">[[0,1,-1],[0,0,-1],[0,0,0]]</span>。<br>接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了<span class="hljs-number">1</span>颗樱桃。<br>在旅程中，总共摘到了<span class="hljs-number">5</span>颗樱桃，这是可以摘到的最大值了。<br></code></pre></td></tr></table></figure><p>说明:<br>grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;= N &lt;= 50。<br>每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。<br>可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cherry-pickup">https://leetcode.cn/problems/cherry-pickup</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>一开始想着用dfs去做，嗯，要走两次，时间复杂度爆炸，就算逻辑是对的，但是根本过不去<br>动态规划我想不出来怎么写，直接一个cv</p><p>1.第二次回归的路程可以看做是从左上角再走一次，也就是两个人同时从原点出发，按自己的路线走一遍，然后<br>统计摘到的樱桃的最大值。<br>也就是f[x1][y1][x2][y2]，同时出发，所以每一步都有四种可能性，f的值等于上一步所有合法值里最大的值，<br>至于为什么可以dp，因为只能从一个方向走，不能回退，也就有无后效性，到达每一个状态的最优路线是可以被枚举的。</p><p>2.有了第一步的分析，就可以推第二步，设每一回合为k，则x1 + y1 = k = x2 + y2恒成立<br>可以把dp数组缩减一维到f[k][x1][x2],每个位置的坐标就是 (x1, k - x1) 和 (x2, k - x2)</p><p>取自三叶佬：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">55</span>, INF = Integer.MIN_VALUE;  <span class="hljs-comment">// N 为本题范围，因题目有负值的格子，定义INF作为dp数组初始化用</span><br>    <span class="hljs-comment">// 定义dp数组用于记录结果，由题意，第二次遍历等价于与第一次相同的规则再走一遍，故总共有2N次结果。</span><br>    <span class="hljs-comment">// 进而可以将问题转换为，两个点从左上角同时开始走，最后都走到右下角的最大得分。</span><br>    <span class="hljs-comment">// dp[k][i1][i2]为当前已走了k步（k 为所在格子的横纵坐标之和），第一个点在i1行，第二个点在i2行的最大得分，最终答案为dp[2n][n][n]。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * N][N][N];  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-comment">// 初始化dp数组为INF</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">2</span> * n; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt;= n; i1++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i2 &lt;=n; i2++) &#123;<br>                    dp[k][i1][i2] = INF;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp[2][1][1] 两个点都在左上角的初始状态，都为0，即 dp[2][1][1] = grid[0][0]</span><br>        dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 从k=3开始，第一个点开始运动。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; k &lt;= <span class="hljs-number">2</span> * n; k++) &#123;<br>            <span class="hljs-comment">// 两个点都从第一行开始，i1和i2都为1到n。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i1 &lt;= n; i1++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i2 &lt;= n; i2++) &#123;<br>                    <span class="hljs-comment">// 计算两个点当前所在的列</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> k - i1, j2 = k -i2;<br>                    <span class="hljs-comment">// 检查越界</span><br>                    <span class="hljs-keyword">if</span> (j1 &lt;= <span class="hljs-number">0</span> || j1 &gt; n || j2 &lt;= <span class="hljs-number">0</span> || j2 &gt; n) <span class="hljs-keyword">continue</span>; <br>                    <span class="hljs-comment">// 检查两个点所在位置是否有障碍，有的话跳过。</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> grid[i1 - <span class="hljs-number">1</span>][j1 - <span class="hljs-number">1</span>], B = grid[i2 - <span class="hljs-number">1</span>][j2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (A == -<span class="hljs-number">1</span> || B == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 确认两个点同时移动都可行，当前第k步可以从原来的两个点状态的最大值转移过来，由于从行走或从列走都有可能，共有四种状态。</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]; <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1][i2];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(Math.max(a, b), Math.max(c, d)) + A;<br>                    <span class="hljs-comment">// 两个点不重合可以同时累加。</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += B;<br>                    <span class="hljs-comment">// 填入现在最佳的结果。</span><br>                    dp[k][i1][i2] = t;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span> * n][n][n] &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[<span class="hljs-number">2</span> * n][n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式和代理模式</title>
    <link href="/shinone.github.io/2022/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/shinone.github.io/2022/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>非常想把这俩一起说，主要是因为真的太像了。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>它可以不改变现有对象的结构，并且添加新的功能，其实就是作为现有类的一个包装。<br>可以不创建过多的子类重写方法，简单的对一两个方法进行增强。<br>1、创建包装器的抽象类，实现装饰对象的接口，内部加一个装饰对象的成员变量，通过构造器传入参数赋值到成员变量上<br>2、造一个包装器的实现类，实现装饰对象的方法，在实现的方法中通过成员变量调用装饰对象的原本的方法，这样在这个调用的前后，就可以做一些方法上的增强<br>3、创建包装器的对象，调用包装器的方法</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式主要是提供一个中间层控制对对象的访问，<br>在代理对象执行目标方法的时候也可以对方法进行增强，比如执行完一个方法之后打印日志、执行查询数据库前切换到对应数据源之类的操作</p><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><p>相似之处就是都能对目标方法做增强。<br>最主要的区别在于：<br>代理模式是控制对目标的访问，在前后做一些增强处理，没有改变对象本身的能力，装饰器模式是让对象本身能做更多的事了</p><p>打个比方：<br>去一个饭店吃饭，我只知道要让厨师做我想吃的菜<br>代理模式：雇了个服务员，服务员点餐-&gt;厨师做菜-&gt;服务员送菜，厨师对客人来说被隐藏了，厨师还是只知道做菜，其余的交给服务员做<br>装饰器模式：厨师通过锻炼变成了超人厨师，自己点餐，自己做菜，自己送菜，</p><h3 id="装饰器模式示例"><a href="#装饰器模式示例" class="headerlink" title="装饰器模式示例"></a>装饰器模式示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java">步骤 <span class="hljs-number">1</span><br>创建一个接口：<br><br>Shape.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br>步骤 <span class="hljs-number">2</span><br>创建实现接口的实体类。<br><br>Rectangle.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Shape: Rectangle&quot;</span>);<br>   &#125;<br>&#125;<br>Circle.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Shape: Circle&quot;</span>);<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">3</span><br>创建实现了 Shape 接口的抽象装饰类。<br><br>ShapeDecorator.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">protected</span> Shape decoratedShape;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span>&#123;<br>      <span class="hljs-built_in">this</span>.decoratedShape = decoratedShape;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>      decoratedShape.draw();<br>   &#125;  <br>&#125;<br>步骤 <span class="hljs-number">4</span><br>创建扩展了 ShapeDecorator 类的实体装饰类。<br><br>RedShapeDecorator.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedShapeDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ShapeDecorator</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span> &#123;<br>      <span class="hljs-built_in">super</span>(decoratedShape);     <br>   &#125;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      decoratedShape.draw();         <br>      setRedBorder(decoratedShape);<br>   &#125;<br> <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRedBorder</span><span class="hljs-params">(Shape decoratedShape)</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Border Color: Red&quot;</span>);<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">5</span><br>使用 RedShapeDecorator 来装饰 Shape 对象。<br><br>DecoratorPatternDemo.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPatternDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>      <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>      <span class="hljs-type">ShapeDecorator</span> <span class="hljs-variable">redCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>      <span class="hljs-type">ShapeDecorator</span> <span class="hljs-variable">redRectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>      <span class="hljs-comment">//Shape redCircle = new RedShapeDecorator(new Circle());</span><br>      <span class="hljs-comment">//Shape redRectangle = new RedShapeDecorator(new Rectangle());</span><br>      System.out.println(<span class="hljs-string">&quot;Circle with normal border&quot;</span>);<br>      circle.draw();<br> <br>      System.out.println(<span class="hljs-string">&quot;\nCircle of red border&quot;</span>);<br>      redCircle.draw();<br> <br>      System.out.println(<span class="hljs-string">&quot;\nRectangle of red border&quot;</span>);<br>      redRectangle.draw();<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">6</span><br>执行程序，输出结果：<br><br>Circle with normal border<br>Shape: Circle<br><br>Circle of red border<br>Shape: Circle<br>Border Color: Red<br><br>Rectangle of red border<br>Shape: Rectangle<br>Border Color: Red<br>示例来源：https:<span class="hljs-comment">//www.runoob.com/design-pattern/decorator-pattern.html</span><br></code></pre></td></tr></table></figure><h3 id="代理模式示例"><a href="#代理模式示例" class="headerlink" title="代理模式示例"></a>代理模式示例</h3><p>jdk的动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) Proxy.newProxyInstance(UserProxyTest.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;User.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserImpl</span>()));<br>        System.out.println(user.add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>        User user;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(UserImpl user)</span>&#123;<br>            <span class="hljs-built_in">this</span>.user = user;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            System.out.println(<span class="hljs-string">&quot;前置&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(user, args);<br>            System.out.println(<span class="hljs-string">&quot;方法执行&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;后置&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装饰器模式</tag>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>648. 单词替换</title>
    <link href="/shinone.github.io/2022/07/07/%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"/>
    <url>/shinone.github.io/2022/07/07/%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>要做的事并没有做完，只是忙到现在实在有点累了，看算法题休息一下</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p><p>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p><p>你需要输出替换之后的句子。</p><blockquote><p>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 100<br>dictionary[i] 仅由小写字母组成。<br>1 &lt;= sentence.length &lt;= 10^6<br>sentence 仅由小写字母和空格组成。<br>sentence 中单词的总量在范围 [1, 1000] 内。<br>sentence 中每个单词的长度在范围 [1, 1000] 内。<br>sentence 中单词之间由一个空格隔开。<br>sentence 没有前导或尾随空格。</p></blockquote><p>示例 1：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：dictionary = [<span class="hljs-comment">&quot;cat&quot;</span>,<span class="hljs-comment">&quot;bat&quot;</span>,<span class="hljs-comment">&quot;rat&quot;</span>], sentence = <span class="hljs-comment">&quot;the cattle was rattled by the battery&quot;</span><br>输出：<span class="hljs-comment">&quot;the cat was rat by the bat&quot;</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/replace-words">https://leetcode.cn/problems/replace-words</a></p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>我自己放空大脑靠直觉写的模拟解法,给字典排个序，然后对每个字符从头开始从字典里找存不存在，存在就替换就行<br>String的api真好用(</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        dictionary.sort((a, b) -&gt; a.length() - b.length());<br>        String[] splits = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; splits.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (String s : dictionary) &#123;<br>                <span class="hljs-keyword">if</span> (splits[i].startsWith(s)) &#123;<br>                    splits[i] = s;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, splits);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>很明显也能构建字典树的方式去查，树形结构，在加上是否尾节点的判断。<br>然后每个单词按照树依次查就行，理论上是这题里最快的解法，摸了半小时该继续了，贴个三叶大佬的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">boolean</span> isEnd;<br>        Node[] tns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u] == <span class="hljs-literal">null</span>) p.tns[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            p = p.tns[u];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    String <span class="hljs-title function_">query</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u].isEnd) <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>            p = p.tns[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; ds, String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : ds) add(str);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String str : s.split(<span class="hljs-string">&quot; &quot;</span>)) sb.append(query(str)).append(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/replace-words/solution/by-ac_oier-jecf/</span><br>来源：力扣（LeetCode）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绘画20220703</title>
    <link href="/shinone.github.io/2022/07/03/%E7%BB%98%E7%94%BB20220703/"/>
    <url>/shinone.github.io/2022/07/03/%E7%BB%98%E7%94%BB20220703/</url>
    
    <content type="html"><![CDATA[<p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/D20220703.png" alt="透视练习"></p><p>…菜菜的透视练习，下一个练头部吧</p>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
      <category>透视</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>522. 最长特殊序列 II</title>
    <link href="/shinone.github.io/2022/06/30/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/"/>
    <url>/shinone.github.io/2022/06/30/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定字符串列表 strs ，返回其中 最长的特殊序列 的长度。如果最长特殊序列不存在，返回 -1 。</p><p>特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。</p><p>s 的 子序列可以通过删去字符串 s 中的某些字符实现。</p><p>例如，”abc” 是 “aebdc” 的子序列，因为您可以删除”aebdc”中的下划线字符来得到 “abc” 。”aebdc”的子序列还包括”aebdc”、 “aeb” 和 “” (空字符串)。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii">https://leetcode.cn/problems/longest-uncommon-subsequence-ii</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>题目很绕，但是其实如果一个字符串str，他本身不是特殊序列，那么所有他的子串都不可能是特殊序列。<br>因为他本身都出现过了，那么子串必然也出现过。<br>再反过来想，如果一个字符串的任何一个子串是特殊序列，那么不管在子串上加多少字符必然都是特殊序列。</p><p>所以这题就变成了：挨个去判断str是不是其他字符串的子序列。<br>然后找出符合条件的str里最长的那个的长度</p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        mm:<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].length() &gt; ans) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; strs.length; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (j != i &amp;&amp; isSubStr(strs[i], strs[j])) &#123;<br>                        <span class="hljs-keyword">continue</span> mm;<br>                    &#125;<br>                &#125;<br>                ans = strs[i].length();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStr</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length(), n = s2.length();<br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>= m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><p>同样的也可以转化成lcs问题，判断一个字符串a和字符串b中的最长公共子序列的长度len，如果len等于a的长度，那么a就是b的一个子序列<br>基本LCS问题: <a href="http://shinone.cn/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/">http://shinone.cn/2022/06/30/最长公共子序列/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].length() &lt;= ans) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; ok; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (check(strs[i], strs[j])) ok = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ok) ans = strs[i].length();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length(), m = s2.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                f[i][j] = s1.charAt(i - <span class="hljs-number">1</span>) == s2.charAt(j - <span class="hljs-number">1</span>) ? f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                f[i][j] = Math.max(f[i][j], f[i - <span class="hljs-number">1</span>][j]);<br>                f[i][j] = Math.max(f[i][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (f[i][j] == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>作者：AC_OIer<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>LCS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143. 最长公共子序列</title>
    <link href="/shinone.github.io/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/shinone.github.io/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：text1 = <span class="hljs-string">&quot;abcde&quot;</span>, text2 = <span class="hljs-string">&quot;ace&quot;</span><br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-common-subsequence">https://leetcode.cn/problems/longest-common-subsequence</a></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> text1.length(),l2 = text2.length();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[l1 + <span class="hljs-number">1</span>][l2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= l1 ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= l2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[l1][l2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>f[i][j]的定义是只考虑到t1的前i个字符和t2的前j个字符，<br>最长的公共子序列是多长。<br>状态转移方程就是，如果新增的字符相等，则最长子序列等于只考虑i-1 和 j-1时的最长长度 + 1；<br>如果新增的字符不相等，则选择不考虑t1的前一个字符或者不考虑t2的前一个字符里更长的那个。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>LCS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>324. 摆动排序 II</title>
    <link href="/shinone.github.io/2022/06/29/%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8FII/"/>
    <url>/shinone.github.io/2022/06/29/%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8FII/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol start="324"><li>摆动排序 II<br>给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。<br>你可以假设所有输入数组都可以得到满足题目要求的结果。</li></ol><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>解释：[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>] 同样是符合题目要求的结果，可以被判题程序接受。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/wiggle-sort-ii/">https://leetcode.cn/problems/wiggle-sort-ii/</a></p><h1 id="快速选择-三路分治-虚拟地址"><a href="#快速选择-三路分治-虚拟地址" class="headerlink" title="快速选择+三路分治+虚拟地址"></a>快速选择+三路分治+虚拟地址</h1><p>来自三叶大佬的题解，只是看懂了而已，并不是我能做得出来的难度…<br>要达到On时间复杂度和O1的空间复杂度是真的…好难啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qselect</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) swap(i, j);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= cnt) <span class="hljs-keyword">return</span> qselect(l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> qselect(j + <span class="hljs-number">1</span>, r, k - cnt);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = c;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>) % (n | <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wiggleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums)</span> &#123;<br>        nums = _nums;<br>        n = nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> qselect(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, loc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (loc &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[getIdx(loc)] &gt; x) swap(getIdx(loc++), getIdx(l++));<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[getIdx(loc)] &lt; x) swap(getIdx(loc), getIdx(r--));<br>            <span class="hljs-keyword">else</span> loc++;<br>        &#125;<br>    &#125;<br>&#125;<br>作者：AC_OIer<br></code></pre></td></tr></table></figure><p>首先肯定是考虑排个序一个大一个小直接开摆就行，但是会出现这种问题:<br>412321排序：112234<br>一个大一个小：413122，然后挂了<br>必须要把中间的2，分到互相远离的地方，也就是：423121 这样才行<br>而且排序的复杂度是nlogn</p><p>首先快速选择算法 On复杂度找到中位数：2<br>然后三路分治排序复杂度是On：小于2的放左边等于2的放中间大于2的放右边 可能是112234也可能是112243</p><p>最后这步，可以用复制一个数组的方式摆，但是空间复杂度就会是On，要降为O1就需要用虚拟地址的方式进行第二步的三路分治<br>也就是写一个函数f(x) -&gt; y<br>x = 0 (1), y = 1<br>x = 1 (1), y = 3<br>x = 2 (2), y = 5<br>x = 3 (2), y = 0<br>x = 4 (3), y = 2<br>x = 5 (4), y = 4<br>排序逻辑正常按照x的值排序，但是实际交换是交换的f(x)的地址，达到错开的效果<br>理论上排序之后的结果：112234<br>实际结果：213142</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速选择</tag>
      
      <tag>虚拟地址</tag>
      
      <tag>三路分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 091. 粉刷房子</title>
    <link href="/shinone.github.io/2022/06/29/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/shinone.github.io/2022/06/29/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: costs = <span class="hljs-string">[[17,2,17],[16,16,5],[14,3,19]]</span><br>输出: <span class="hljs-number">10</span><br>解释: 将 <span class="hljs-number">0</span> 号房子粉刷成蓝色，<span class="hljs-number">1</span> 号房子粉刷成绿色，<span class="hljs-number">2</span> 号房子粉刷成蓝色。<br>最少花费: <span class="hljs-number">2</span> + <span class="hljs-number">5</span> + <span class="hljs-number">3</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/JEj789">https://leetcode.cn/problems/JEj789</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] cs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> cs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b = cs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], c = cs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.min(b + cs[i][<span class="hljs-number">0</span>], c + cs[i][<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> Math.min(a + cs[i][<span class="hljs-number">1</span>], c + cs[i][<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Math.min(a + cs[i][<span class="hljs-number">2</span>], b + cs[i][<span class="hljs-number">2</span>]);<br>            a=d; b = e; c = f;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(Math.min(a, b), c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记最后一栋房子刷abc三种油漆的总价分别为Ca Cb Cc，第i号房子刷的油漆价格为ai bi ci。</p><p>已知房子0，刷三种颜色的油漆分别需要a0(cs[0][1])、b0(cs[0][2])、c0(cs[0][3])<br>这时候的总价为 Ca = a0, Cb = b0, Cc = c0;</p><p>房子0 + 房子1 刷每种油漆的价格最低的总价计算方式：<br>因为房子颜色不能重复，房子1 要刷a颜料，那么就只能a1加上上一栋房子，也就是房子0的b和c颜料这俩里价格更低的那个:<br>Ca = Min(a1 + Cb, a1 + Cc);<br>意思就是房子1刷a颜料，考虑到房子0，总价的最低价格是多少；<br>依次算出Cb和Cc，然后保持这个计算方式推完所有房子；<br>到最后一栋房子的时候得到三个最低总价，取三个中最低的那个就是最后的答案。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>535. tinyurl的加密与解密</title>
    <link href="/shinone.github.io/2022/06/29/tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    <url>/shinone.github.io/2022/06/29/tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a> 。请你设计一个类来加密与解密 TinyURL 。</p><p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p><p>实现 Solution 类：</p><p>Solution() 初始化 TinyURL 系统对象。<br>String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。<br>String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/encode-and-decode-tinyurl">https://leetcode.cn/problems/encode-and-decode-tinyurl</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h1><p>首先要保证长url不管加密多少次都会得到相同的短url，<br>然后要保证一个短url一定对应原有的长url；</p><h1 id="无为而治"><a href="#无为而治" class="headerlink" title="无为而治"></a>无为而治</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String longUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> longUrl;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String shortUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> shortUrl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好，我答完了（草）</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; origin2Tiny = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>), tiny2Origin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://shinone.com/&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">K</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String longUrl)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!origin2Tiny.containsKey(longUrl)) &#123;<br>            <span class="hljs-type">char</span>[] cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[K];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; K; i++) cs[i] = str.charAt(random.nextInt(str.length()));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prefix + String.valueOf(cs);<br>            <span class="hljs-keyword">if</span> (tiny2Origin.containsKey(cur)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">synchronized</span> (Codec.class) &#123;<br>                <span class="hljs-keyword">if</span> (tiny2Origin.containsKey(cur)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (!origin2Tiny.containsKey(longUrl)) &#123;<br>                    tiny2Origin.put(cur, longUrl);<br>                    origin2Tiny.put(longUrl, cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> origin2Tiny.get(longUrl);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String shortUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> tiny2Origin.get(shortUrl);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当工具类用不加锁会出大问题<br>单体应用好像可以这么搞，分布式的话得弄个缓存当哈希表用，还可以设置超时时间。<br>单体要弄超时的话就把value再封装进一个类里，然后不主动去删除，在每次判断包含不包含的时候，再额外判断一次是否超时，超时了就可以覆盖掉就行。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>tinyurl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待填坑事项</title>
    <link href="/shinone.github.io/2022/06/28/%E5%BE%85%E5%A1%AB%E5%9D%91%E4%BA%8B%E9%A1%B9/"/>
    <url>/shinone.github.io/2022/06/28/%E5%BE%85%E5%A1%AB%E5%9D%91%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h1><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p>说好的把所有听的歌的音源整理之后存云盘上，结果现在进度只有七分之一，怎么辉石呢</p>]]></content>
    
    
    <categories>
      
      <category>挖坑不埋</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="/shinone.github.io/2022/06/24/%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/shinone.github.io/2022/06/24/%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/20220624.png" alt="在每个树行中找最大值"></p><p>来源:<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p><h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.addLast(root);<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size(), max = deque.peek().val;<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> deque.poll();<br>                max = Math.max(poll.val, max);<br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) deque.addLast(poll.left);<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) deque.addLast(poll.right);<br>            &#125;<br>            list.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一直都是用dfs在做，今天这题dfs的话要用一个哈希表维护深度和最大值，感觉有点麻烦，还是bfs吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过配置文件动态过滤springboot的自动装配类</title>
    <link href="/shinone.github.io/2022/06/24/%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB/"/>
    <url>/shinone.github.io/2022/06/24/%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在引入redis做缓存之后，即使在spring.redis.enable配置项上设为false，不启用缓存，依然会自动配置redis的连接，<br>不配置连接就无法正常启动。<br>现在需要通过这个配置项去控制启动项目的时候是否去自动装载redis，在@springbootApplication上exclude无法做到这样的控制。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="新增配置类"><a href="#新增配置类" class="headerlink" title="新增配置类"></a>新增配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfigurationImportFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoConfigurationImportFilter</span>, EnvironmentAware &#123;<br>    <span class="hljs-comment">// 1.实现EnvironmentAware接口，重写setEnvironment方法，获取到配置文件环境变量</span><br>    <span class="hljs-keyword">private</span> Environment environment;<br>    <span class="hljs-comment">// 2.用一个map存储需要判断哪些配置值以及需要剔除的配置类(也可以选择其他方式)</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; filterAutoConfigurationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 3.这里是通过构造方法初始化需要过滤的类，也可以选择其他方式</span><br>    <span class="hljs-comment">// key为配置，value是剔除配置类的全类名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisAutoConfigurationImportFilter</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration&quot;</span>);<br>        filterAutoConfigurationMap.put(<span class="hljs-string">&quot;spring.redis.enable&quot;</span>, list);<br>    &#125;<br>    <span class="hljs-comment">// 4.实现AutoConfigurationImportFilter接口，重写判断逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span>[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;<br>        <span class="hljs-comment">// 需要剔除的类集合</span><br>        Set&lt;String&gt; filterClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 根据配置值判断是否需要剔除</span><br>        filterAutoConfigurationMap.forEach((k, v) -&gt; &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">enableProperty</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.environment.getProperty(k, Boolean.class);<br>            <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(enableProperty)) &#123;<br>                filterClass.addAll(v);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (filterClass.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">boolean</span>[] skip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[autoConfigurationClasses.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; autoConfigurationClasses.length; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">autoConfigurationClass</span> <span class="hljs-operator">=</span> autoConfigurationClasses[i];<br>                <span class="hljs-keyword">if</span> (!filterClass.contains(autoConfigurationClass)) &#123;<br>                    skip[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> skip;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(Environment environment)</span> &#123;<br>        <span class="hljs-built_in">this</span>.environment = environment;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在resource文件夹下新建META-INF文件夹，新建spring-factories文件"><a href="#在resource文件夹下新建META-INF文件夹，新建spring-factories文件" class="headerlink" title="在resource文件夹下新建META-INF文件夹，新建spring.factories文件"></a>在resource文件夹下新建META-INF文件夹，新建spring.factories文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 替换成自己的全类名</span><br><span class="hljs-attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.xxx.xxx.config.RedisAutoConfigurationImportFilter</span><br></code></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在不自动装载redis后，自动注入redisTemplate会报错，如果有配置redisUtil类，可以用@conditionOnProperties控制不自动注册</p><h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><ol><li><p>从spring.factories配置文件中加载自动配置类，在这一步会用LinkedHashSet()去重;</p></li><li><p>加载的自动配置类中排除掉 @EnableAutoConfiguration 注解的 exclude 属性指定的自动配置类；</p></li><li><p>然后再用 AutoConfigurationImportFilter 接口去过滤自动配置类是否符合其标注注解（若有标注的话） @ConditionalOnClass , @ConditionalOnBean 和<br>@ConditionalOnWebApplication 的条件，若都符合的话则返回匹配结果；<br>在这一步spring会从spring.properties中读取所有AutoConfigurationImportFilter接口的实现类，然后用迭代器依次执行match方法，最后得到一个boolen[]</p></li><li><p>然后触发 AutoConfigurationImportEvent，告诉ConditionEvaluationReport条件评估报告器对象来分别记录符合条件和 exclude 的自动配置类。</p></li><li><p>最后spring再将最后筛选后的自动配置类导入IOC容器中</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>自动装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视练习-20220622</title>
    <link href="/shinone.github.io/2022/06/22/%E7%BB%98%E7%94%BB20220622/"/>
    <url>/shinone.github.io/2022/06/22/%E7%BB%98%E7%94%BB20220622/</url>
    
    <content type="html"><![CDATA[<p><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/D20220622.jpg" alt="场景透视练习"><br>…算是挺久之前的练习了，想初始化一下板绘这边的分类就传上来吧<br>基本上所有物件都是对齐透视方向，旋转、浮空方块、倾斜这些，都完全没有()<br>画的我FF14里的家</p>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
      <category>透视</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>513. 找树左下角的值</title>
    <link href="/shinone.github.io/2022/06/22/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <url>/shinone.github.io/2022/06/22/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。<br><img src="https://shinone.oss-cn-chengdu.aliyuncs.com/picture/source/20220622.png" alt="示例"><br><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> deep)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (deep &gt; d) &#123;<br>            result = root.val;<br>            d = deep;<br>        &#125;<br>        dfs(root.left, deep + <span class="hljs-number">1</span>);<br>        dfs(root.right, deep + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>蛮简单的，上次做这道题是21年的7月份，不知不觉一年就过去了啊…</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>508. 出现次数最多的子树元素和</title>
    <link href="/shinone.github.io/2022/06/20/%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <url>/shinone.github.io/2022/06/20/%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p>一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[5,2,-3]</span><br>输出: <span class="hljs-comment">[2,-3,4]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[5,2,-5]</span><br>输出: <span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/most-frequent-subtree-sum">https://leetcode.cn/problems/most-frequent-subtree-sum</a></p><h1 id="DFS-哈希"><a href="#DFS-哈希" class="headerlink" title="DFS+哈希"></a>DFS+哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findFrequentTreeSum(TreeNode root) &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        count(root);<br>        ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (e.getValue() == max) arrayList.add(e.getKey());<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arrayList.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; i++) result[i] = arrayList.get(i);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> root.val + count(root.left) + count(root.right);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">orDefault</span> <span class="hljs-operator">=</span> map.getOrDefault(count, <span class="hljs-number">0</span>);<br>        orDefault++;<br>        map.put(count, orDefault);<br>        max = Math.max(max, orDefault);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>532. 数组中的 k-diff 数对</title>
    <link href="/shinone.github.io/2022/06/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-diff%E6%95%B0%E5%AF%B9/"/>
    <url>/shinone.github.io/2022/06/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-diff%E6%95%B0%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p><p>k-diff 数对定义为一个整数对 (nums[i], nums[j]) ，并满足下述全部条件：</p><p>0 &lt;= i, j &lt; nums.length<br>i != j<br>nums[i] - nums[j] == k<br>注意，|val| 表示 val 的绝对值。</p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3, 1, 4, 1, 5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：数组中有两个 <span class="hljs-number">2</span>-diff 数对, (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) 和 (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)。<br>尽管数组中有两个 <span class="hljs-number">1</span> ，但我们只应返回不同的数对的数量。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1, 2, 3, 4, 5]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：数组中有四个 <span class="hljs-number">1</span>-diff 数对, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) 和 (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array">https://leetcode.cn/problems/k-diff-pairs-in-an-array</a></p><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>            Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(i - k)) set2.add(i - k);<br>                <span class="hljs-keyword">if</span> (set.contains(i + k)) set2.add(i);<br>                set.add(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> set2.size();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为今天是简单题，闲来无事就把昨天的中等题搬一下…<br>每个数对只统计一次，所以可以直接用第二个哈希表去重。<br>注意点就在于，如果同时存在1 3 5，k = 2的时候，如果只往数组里存i - k 和 i + k 就会出问题。<br>到3的时候因为数组里没有5，所以会存一个重复的1进去， 到5的时候再把3存进去，但是5他自己本身不会存进去的，因为他是最后一个数了。<br>所以得改成存 i - k 和 i 或者 i + k 和 i确保不会出现上面那种情况。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>719.找出第k小的数对距离</title>
    <link href="/shinone.github.io/2022/06/15/%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/"/>
    <url>/shinone.github.io/2022/06/15/%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</p><p>给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 &lt;= i &lt; j &lt; nums.length 。返回 所有数对距离中 第 k 小的数对距离。</p><p> </p><p>示例 1：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：数对和对应的距离如下：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br>距离第 <span class="hljs-number">1</span> 小的数对是 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) ，距离为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance">https://leetcode.cn/problems/find-k-th-smallest-pair-distance</a></p><h1 id="排序-二分-双指针"><a href="#排序-二分-双指针" class="headerlink" title="排序 + 二分 + 双指针"></a>排序 + 二分 + 双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestDistancePair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>            Arrays.sort(nums);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums[nums.length - <span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (check(nums, mid) &gt;= k) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= x) j++;<br>                ans += j - i - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例：[1, 6, 1]  k = 3<br>因为题目指出，要排序的是值的绝对差，所以可以先进行一次排序，得到<br>[1, 1, 6]<br>排序后的数列两个元素之间的差就会是一个递增的数列<br>1、这时数列中，一定会存在一个值A一定满足：大于等于这个差值A，必然有数列中任意两个元素的差值B &lt; A 的所有个数,大于等于k<br>如：A=6的个数&gt;=3，A=5的个数也是&gt;=3,即：1-1&lt;6 , 6-1&lt;6, 6-1&lt;6一共三组<br>小于这个差值A，则不一定满足这个条件，如[2, 3, 7] k = 1; mid = (5 + 0) &gt;&gt; 1 = 2,当2为A值的时候刚好个数为1大于等于k<br>2、这时候A的下界是0，上界是最大值减去最小值，也就是6-1 = 5，在这个范围内进行二分查找，最后的A值一定就是题目需要的第k小的值<br>(描述的支离破碎，相信未来的我一定能看懂（）)</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051.高度检查器</title>
    <link href="/shinone.github.io/2022/06/13/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
    <url>/shinone.github.io/2022/06/13/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。</p><p>排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。</p><p>给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。</p><p>返回满足 heights[i] != expected[i] 的 下标数量 。</p><p> </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<br>高度：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>预期：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>下标 <span class="hljs-number">2</span> 、<span class="hljs-number">4</span> 、<span class="hljs-number">5</span> 处的学生高度不匹配。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：<br>高度：[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>预期：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>所有下标的对应学生高度都不匹配。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/height-checker">https://leetcode.cn/problems/height-checker</a></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>读完题目第一反应当然就是copy一个数组之后进行排序，然后再依次对比每一位上的数对不对。<br>这样做的时间复杂度是O(NlogN)<br>不过实际上不需要进行比较排序，因为这题的整数范围非常小可以先建立一个长度为数组最大值的统计数组，记录下每个数字出现了多少次。<br>然后再循环取出统计数组里的值和原数组一一比对就行，时间复杂度是O(n + k) k是整数的范围。<br>所以能看出来计数排序是用空间换时间，当范围太大的时候就不适合了，具体就是当k大于NlogN的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">heightChecker</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height : heights) &#123;<br>            count[height]++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (count[i]-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (heights[j++] != i) result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/shinone.github.io/2022/06/07/CompletableFuture/"/>
    <url>/shinone.github.io/2022/06/07/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><blockquote><p>之前juc一直是看书学，对，就java并发编程的艺术，看完之后不仅很长时间没用上，而且后来才知道它是基于jdk1.7写的，<br>在1.8版本不仅多了completableFuture,ConcurrentHashMap的结构也发生改变等等…<br>于是现在继续补坑</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java8中,CompletableFuture提供了非常强大的Future的扩展功能,可以帮助我们简化异步编程的复杂性,<br>并且提供了函数式编程的能力,可以通过回调的方式处理计算结果,也提供了转换和组合CompletableFuture的方法，<br>支持在完成之后触发一些函数或执行一些操作。<br>    主要实现了Future接口和completionStage接口。<br>    completionStage表示异步操作中的某个阶段，一个阶段完成后可以执行另一个阶段，每个阶段可以执行不同的操作，<br>如thenAccept、thenRun、thenApply</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol><li>提供了四个静态方法来创建</li><li>runAsync方法不支持返回值、supplyAsync方法可以支持返回值</li><li>如果不传入executor会用ForkJoinPool.commonPool()作为它的线程池执行异步代码。如果指定线程池,则使用指定的线程池运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//runAsync方法不支持返回值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br><span class="hljs-comment">//supplyAsync可以支持返回值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p>和future不同，不需要创建线程再启动，源码中创建对象之后会直接提交启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                                 Supplier&lt;U&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><ol><li>get( ) 只要调用了get( )方法,不管是否计算完成都会导致阻塞(会抛出异常)</li><li>get(long timeout, TimeUnit unit) 输入一个等待时间，超时后会继续向下运行</li><li>getNow(T valuelfAbsent) 没有计算完成的情况下,返回一个替代结果。计算完成的话返回计算完成后的结果</li><li>join( ) join方法和get( )方法作用一样,不同的是,join方法不会抛出异常</li></ol><h3 id="对结果进行处理"><a href="#对结果进行处理" class="headerlink" title="对结果进行处理"></a>对结果进行处理</h3><ol><li>handle<br>当上一个阶段正常或者异常完成的时候会调用handle中定义的方法进行运算，并将运算结果或者异常作为参数传递给下一个阶段，<br>因此就算在执行中出现异常并不会中止执行，而是会继续向下传递。<ol><li>handle 用当前的线程继续执行</li><li>handleAsync 不添加线程池参数，用默认的线程池(ForkJoinPool.commonPool())重新开一个线程执行；提供参数，用指定的线程池执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2L</span>,TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2L</span>,TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool2-&quot;</span>));<br>        <br>        CompletableFuture.supplyAsync(() -&gt;&#123;<br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;,executor1).handle((f,e) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;222&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>        &#125;).handleAsync((f,e) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;333&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">3</span>;<br>        &#125;, executor2).whenComplete((v,e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----计算结果： &quot;</span>+v);<br>        &#125;<br>        &#125;).exceptionally(e -&gt; &#123;<br>        e.printStackTrace();<br>        System.out.println(e.getMessage());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;----主线程先去忙其它任务&quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>执行结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">main----主线程先去忙其它任务<br><span class="hljs-number">111</span><br>clear-cache-pool1-<span class="hljs-number">1</span><br><span class="hljs-number">222</span><br>clear-cache-pool1-<span class="hljs-number">1</span><br><span class="hljs-number">333</span><br>clear-cache-pool2-<span class="hljs-number">1</span><br>----计算结果： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li></ol></li><li>whenComplete<br> 上一步执行完成之后对结果value或者异常exception进行处理，没有返回值，并将v和e继续向下一步传递，类似于finally<ol><li>whenComplete</li><li>whenCompleteAsync 同上，交给线程池去执行</li></ol></li><li>exceptionally<br> 上一步结束如果出现异常则执行这一步的处理，可以有返回值,返回值类型需要和上一个消费性操作相同(handle、apply),<br>如thenRun的返回类型是Void，那么exceptionally的返回类型也为Void<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool2-&quot;</span>));<br>        CompletableFuture&lt;Integer&gt; exceptionally = CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;, executor1).handle((f, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;222&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>        &#125;).handleAsync((f, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;333&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> f + <span class="hljs-number">3</span>;<br>        &#125;, executor2).whenComplete((v, e) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;计算结果： &quot;</span> + v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;出异常了&quot;</span> + v);<br>            &#125;<br>        &#125;).whenComplete((v, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第二个whenComplete的v:&quot;</span> + v);<br>            System.out.println(<span class="hljs-string">&quot;第二个whenComplete的e:&quot;</span> + e);<br>        &#125;).exceptionally(e -&gt; &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;第一个exceptionally:&quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125;).whenComplete((v, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第三个whenComplete的v:&quot;</span> + v);<br>            System.out.println(<span class="hljs-string">&quot;第三个whenComplete的e:&quot;</span> + e);<br>        &#125;).exceptionally(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第二个exceptionally:&quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;最终结果&quot;</span> + exceptionally.join());<br>        executor1.shutdown();<br>        executor2.shutdown();<br>    &#125;<br>执行结果：<br>        <span class="hljs-number">111</span><br>        clear-cache-pool1-<span class="hljs-number">1</span><br>        <span class="hljs-number">222</span><br>        clear-cache-pool1-<span class="hljs-number">1</span><br>        <span class="hljs-number">333</span><br>        clear-cache-pool2-<span class="hljs-number">1</span><br>        出异常了<span class="hljs-literal">null</span><br>        第二个whenComplete的v:<span class="hljs-literal">null</span><br>        第二个whenComplete的e:java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero<br>        第一个exceptionally:java.lang.ArithmeticException: / by zero<br>        第三个whenComplete的v:<span class="hljs-number">10</span><br>        第三个whenComplete的e:<span class="hljs-literal">null</span><br>        最终结果<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h3></li><li>thenRun 开启一个新的任务，不需要参数也没有返回值</li><li>thenAccept 需要一个参数，但是没有返回值 (返回一个Void)</li><li>thenApply 需要一个参数，有一个返回值 (返回一个Void)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <span class="hljs-type">Void</span> <span class="hljs-variable">exceptionally</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;, executor1)<br>                .thenApply(f -&gt; f + <span class="hljs-number">2</span>)<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;apply的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;apply的异常:&quot;</span> + e);<br>                &#125;)<br>                .thenAccept((v) -&gt; System.out.println(<span class="hljs-string">&quot;accept:&quot;</span> + v))<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;accept的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;accept的异常:&quot;</span> + e);<br>                &#125;)<br>                .thenRun(() -&gt; System.out.println(<span class="hljs-string">&quot;run:&quot;</span> + Thread.currentThread().getName()))<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;run的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;run的异常:&quot;</span> + e);<br>                &#125;).join();<br>        System.out.println(exceptionally);<br>        executor1.shutdown();<br>    &#125;<br>执行结果：<br>        <span class="hljs-number">111</span><br>        apply的结果:<span class="hljs-number">3</span><br>        apply的异常:<span class="hljs-literal">null</span><br>        accept:<span class="hljs-number">3</span><br>        accept的结果:<span class="hljs-literal">null</span><br>        accept的异常:<span class="hljs-literal">null</span><br>        run:clear-cache-pool1-<span class="hljs-number">1</span><br>        run的结果:<span class="hljs-literal">null</span><br>        run的异常:<span class="hljs-literal">null</span><br>        <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h3></li><li>applyToEither:两个任务只要有一个执行完成,获取它的返回值,处理任务并有新的返回值</li><li>acceptEither:两个任务只要有一个执行完成,获取它的返回值,处理任务,没有新的返回值</li><li>runAfterEither:两个任务只要有一个执行完成,不需要参数,处理任务,也没有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEither</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn,</span><br><span class="hljs-params">        Executor executor)</span><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEither</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action,</span><br><span class="hljs-params">    Executor executor)</span><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEither</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span><br>                                                  <br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span>   <br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                       Runnable action,</span><br><span class="hljs-params">                                                       Executor executor)</span><br></code></pre></td></tr></table></figure><h3 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h3>两个任务都完成之后进行下一步操作</li><li>thenCombine 两个参数，有返回值</li><li>thenAcceptBoth 两个参数，无返回值</li><li>runAfterBoth 不需要参数也没有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombine</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombineAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span><br> <span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombineAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn, Executor executor)</span><br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBoth</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBothAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action)</span> <br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBothAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action, Executor executor)</span>      <br><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBoth</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                Runnable action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                     Runnable action)</span>  <br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                     Runnable action,</span><br><span class="hljs-params">                                                     Executor executor)</span><br></code></pre></td></tr></table></figure><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3>两个都是静态方法</li><li>allOf 等待所有任务完成，无返回值</li><li>anyOf 只要有一个任务完成，返回该任务的返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">allOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;<br>    <span class="hljs-keyword">return</span> andTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">anyOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;<br>    <span class="hljs-keyword">return</span> orTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><p>初步施工完成，待未来补充</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>875.爱吃香蕉的珂珂</title>
    <link href="/shinone.github.io/2022/06/07/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <url>/shinone.github.io/2022/06/07/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p><p> </p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输出：<span class="hljs-number">4</span><br>输入：piles = [<span class="hljs-number">3,6,7,11</span>], h = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：piles = <span class="hljs-string">[30,11,23,4,20]</span>, h = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/koko-eating-bananas">https://leetcode.cn/problems/koko-eating-bananas</a></p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : piles) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; max) max = i;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (sum / h), r = max;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(piles, mid, h)) &#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : piles) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">1.0</span> / m;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i / m;<br>            ans += b &lt; a ? b + <span class="hljs-number">1</span> : b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt;= h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>选定一个吃香蕉的速度，高于这个速度，一定能吃完，低于这个速度一定吃不完。<br>于是可以用二分求出这个值是多少</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>929. 独特的电子邮件地址</title>
    <link href="/shinone.github.io/2022/06/05/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/"/>
    <url>/shinone.github.io/2022/06/05/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 ‘@’ 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 ‘.’ 或 ‘+’ 。</p><p>例如，在 <a href="mailto:&#97;&#108;&#105;&#x63;&#x65;&#64;&#x6c;&#101;&#x65;&#x74;&#x63;&#x6f;&#100;&#101;&#x2e;&#99;&#111;&#x6d;">&#97;&#108;&#105;&#x63;&#x65;&#64;&#x6c;&#101;&#x65;&#x74;&#x63;&#x6f;&#100;&#101;&#x2e;&#99;&#111;&#x6d;</a>中， alice 是 本地名 ，而 leetcode.com 是 域名 。<br>如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（’.’），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。</p><p>例如，”<a href="mailto:&#x61;&#x6c;&#105;&#99;&#x65;&#46;&#x7a;&#64;&#x6c;&#101;&#x65;&#x74;&#x63;&#x6f;&#100;&#101;&#46;&#99;&#x6f;&#x6d;">&#x61;&#x6c;&#105;&#99;&#x65;&#46;&#x7a;&#64;&#x6c;&#101;&#x65;&#x74;&#x63;&#x6f;&#100;&#101;&#46;&#99;&#x6f;&#x6d;</a>” 和 “<a href="mailto:&#x61;&#x6c;&#105;&#x63;&#x65;&#122;&#x40;&#x6c;&#101;&#x65;&#116;&#99;&#x6f;&#x64;&#x65;&#46;&#99;&#x6f;&#109;">&#x61;&#x6c;&#105;&#x63;&#x65;&#122;&#x40;&#x6c;&#101;&#x65;&#116;&#99;&#x6f;&#x64;&#x65;&#46;&#99;&#x6f;&#109;</a>” 会转发到同一电子邮件地址。<br>如果在 本地名 中添加加号（’+’），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。</p><p>例如 <a href="mailto:&#x6d;&#x2e;&#121;&#43;&#x6e;&#x61;&#x6d;&#101;&#64;&#101;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;">&#x6d;&#x2e;&#121;&#43;&#x6e;&#x61;&#x6d;&#101;&#64;&#101;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a> 将转发到 <a href="mailto:&#109;&#121;&#64;&#101;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#109;&#121;&#64;&#101;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;</a>。<br>可以同时使用这两个规则。</p><p>给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p><p>示例 1：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：emails = [<span class="hljs-string">&quot;test.email+alex@leetcode.com&quot;</span>,<span class="hljs-string">&quot;test.e.mail+bob.cathy@leetcode.com&quot;</span>,<span class="hljs-string">&quot;testemail+david@lee.tcode.com&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：实际收到邮件的是 <span class="hljs-string">&quot;testemail@leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;testemail@lee.tcode.com&quot;</span>。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/unique-email-addresses">https://leetcode.cn/problems/unique-email-addresses</a></p><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numUniqueEmails</span><span class="hljs-params">(String[] emails)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : emails) &#123;<br>            String[] ss = s.split(<span class="hljs-string">&quot;@&quot;</span>);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : ss[<span class="hljs-number">0</span>].toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">break</span>;<br>                builder.append(c);<br>            &#125;<br>            set.add(builder + <span class="hljs-string">&quot;@&quot;</span> +ss[<span class="hljs-number">1</span>]);<br>        &#125; <br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是很简单的模拟题</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>473. 火柴拼正方形</title>
    <link href="/shinone.github.io/2022/06/01/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/shinone.github.io/2022/06/01/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: matchsticks = [1,1,2,2,2]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 能拼成一个边长为2的正方形，每边两根火柴。</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/matchsticks-to-square">https://leetcode.cn/problems/matchsticks-to-square</a></p><h1 id="回溯法-dfs"><a href="#回溯法-dfs" class="headerlink" title="回溯法-dfs"></a>回溯法-dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">makesquare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] matchsticks)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLen</span> <span class="hljs-operator">=</span> Arrays.stream(matchsticks).sum();<br>        <span class="hljs-keyword">if</span> (totalLen % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Arrays.sort(matchsticks);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matchsticks.length - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matchsticks[i];<br>            matchsticks[i] = matchsticks[j];<br>            matchsticks[j] = temp;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, matchsticks, edges, totalLen / <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] matchsticks, <span class="hljs-type">int</span>[] edges, <span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;<br>            edges[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (edges[i] &lt;= len &amp;&amp; dfs(index + <span class="hljs-number">1</span>, matchsticks, edges, len)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            edges[i] -= matchsticks[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、先求出所有火柴的长度总和，如果总和模4不为0则直接返回<br>2、对火柴长度从大到小排序（这一步是为了在dfs的时候降低时间消耗）<br>3、数组edges记录四个边的当前长度，然后依次把每一根火柴放入一个边进行尝试，失败就回溯状态换下一条边， 找到一个能恰好全部放下的结果<br>因为有四条边，每根火柴都要尝试四次，所以每新增一根火柴就要乘上四次。<br>时间复杂度O(4^n)</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 114. 外星文字典</title>
    <link href="/shinone.github.io/2022/05/31/%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8/"/>
    <url>/shinone.github.io/2022/05/31/%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p><p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p><p>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p><p>示例 1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;wrt&quot;</span>,<span class="hljs-string">&quot;wrf&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;ett&quot;</span>,<span class="hljs-string">&quot;rftt&quot;</span>]<br>输出：<span class="hljs-string">&quot;wertf&quot;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>]<br>输出：<span class="hljs-string">&quot;zx&quot;</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：不存在合法字母顺序，因此返回 <span class="hljs-string">&quot;&quot;</span> 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/Jf1JuT">https://leetcode.cn/problems/Jf1JuT</a></p><h1 id="建图-拓扑排序-bfs"><a href="#建图-拓扑排序-bfs" class="headerlink" title="建图+拓扑排序+bfs"></a>建图+拓扑排序+bfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>            Map&lt;Character, Set&lt;Character&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">26</span>); <span class="hljs-comment">// 指向</span><br>            <span class="hljs-type">int</span>[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 入度</span><br>            Set&lt;Character&gt; countSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// 出现过的字母</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> words.length;<br>            Arrays.fill(in, -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 构建图</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-comment">// 统计所有出现过的字母</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : words[i].toCharArray()) &#123;<br>                    countSet.add(c);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 统计各字母的入度</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">char</span>[] chars1 = words[i - <span class="hljs-number">1</span>].toCharArray();<br>                    <span class="hljs-type">char</span>[] chars2 = words[i].toCharArray();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">clen</span> <span class="hljs-operator">=</span> Math.min(chars1.length, chars2.length);<br>                    <span class="hljs-keyword">while</span> (index &lt; clen &amp;&amp; chars1[index] == chars2[index]) index++;<br>                    <span class="hljs-keyword">if</span> (index == clen)&#123;<br>                        <span class="hljs-keyword">if</span> (chars1.length &gt; clen) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    build(map, chars1[index], chars2[index], in);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//bfs</span><br>            Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>                <span class="hljs-comment">// 出现过，并且入度为0的字母全都加入队列</span><br>                <span class="hljs-keyword">if</span> (countSet.contains((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + i)) &amp;&amp; in[i] &lt; <span class="hljs-number">1</span>)&#123;<br>                    deque.addLast((<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;a&#x27;</span>));<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>                <span class="hljs-comment">// 把队列首部的字母全都组装起来，并且它所到达的字母入度减一，</span><br>                <span class="hljs-comment">// 把所有入度为0的字母再加到队列尾部</span><br>                <span class="hljs-type">Character</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>                builder.append(c1);<br>                Set&lt;Character&gt; set = map.getOrDefault(c1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : set)&#123;<br>                    in[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (in[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) deque.addLast(c);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> builder.length() == countSet.size() ? builder.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 建立c1-&gt;c2的单向边</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(Map&lt;Character, Set&lt;Character&gt;&gt; map, <span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2, <span class="hljs-type">int</span>[] in)</span> &#123;<br>            <span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-keyword">return</span>;<br>            Set&lt;Character&gt; c1Set = map.getOrDefault(c1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            <span class="hljs-keyword">if</span> (!c1Set.contains(c2))&#123;<br>                c1Set.add(c2);<br>                <span class="hljs-keyword">if</span> (in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">0</span>;<br>                in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map.put(c1, c1Set);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>主要知识点是拓扑排序，还是很容易理解的。<br>贴一下有图解的博客链接：<br><a href="https://blog.csdn.net/chenweiye1/article/details/113563417">https://blog.csdn.net/chenweiye1/article/details/113563417</a><br>题目里的坑主要集中于以下几个用例：<br>[“x”, “x”]: “x”<br>[“xy”, “x”]: “”<br>[“x”, “xy”]: “xy”</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>广度优先搜索</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1022.从根到叶的二进制数之和</title>
    <link href="/shinone.github.io/2022/05/30/%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/shinone.github.io/2022/05/30/%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><p>例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers">https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers</a></p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRootToLeaf</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>            dfs(root, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> i)</span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>            i = (i &lt;&lt; <span class="hljs-number">1</span>) ^ root.val;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                result += i;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            dfs(root.left, i);<br>            dfs(root.right, i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单题</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面各种初始化学习</title>
    <link href="/shinone.github.io/2022/05/27/%E9%A1%B5%E9%9D%A2%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/shinone.github.io/2022/05/27/%E9%A1%B5%E9%9D%A2%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化第一篇文章</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
