<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>731. 我的日程安排表 II</title>
    <link href="/2022/07/19/%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8II/"/>
    <url>/2022/07/19/%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<p>正常思考就是造一个数组，每次新增就+1，问题是数据范围是1e9，空间不够，<br>然后再进一步用list&lt;int[]&gt; 装数组，每次新增都去遍历统计，但是时间复杂度很高，而且空间用的还是很多<br>再优化一步，可以用treemap作为差分数组储存，空间就小了很多，但是还是要每次都遍历,<br>最优解法是线段树。</p><p>我自己只能做到差分数组那一步，线段树就是纯学习了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;= x &lt; end。</p><p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p><p>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p> </p><p>示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MyCalendar()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">50</span>, <span class="hljs-number">60</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>); <span class="hljs-comment">// returns false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// returns true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyCalendar</span>.</span></span>book(<span class="hljs-number">25</span>, <span class="hljs-number">55</span>); <span class="hljs-comment">// returns true</span><br>解释：<br>前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。<br>第四个日程安排活动（<span class="hljs-number">5</span>,<span class="hljs-number">15</span>）不能添加至日历中，因为它会导致三重预订。<br>第五个日程安排（<span class="hljs-number">5</span>,<span class="hljs-number">10</span>）可以添加至日历中，因为它未使用已经双重预订的时间<span class="hljs-number">10</span>。<br>第六个日程安排（<span class="hljs-number">25</span>,<span class="hljs-number">55</span>）可以添加至日历中，因为时间 <span class="hljs-literal">[<span class="hljs-number">25</span>,<span class="hljs-number">40</span>]</span> 将和第三个日程安排双重预订；<br>时间 <span class="hljs-literal">[<span class="hljs-number">40</span>,<span class="hljs-number">50</span>]</span> 将单独预订，时间 <span class="hljs-literal">[<span class="hljs-number">50</span>,<span class="hljs-number">55</span>）将和第二个日程安排双重预订。</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/my-calendar-ii">https://leetcode.cn/problems/my-calendar-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarTwo</span> &#123;<br>    TreeMap&lt;Integer, Integer&gt; cnt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarTwo</span><span class="hljs-params">()</span> &#123;<br>        cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer, Integer&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxBook</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        cnt.put(start, cnt.getOrDefault(start, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        cnt.put(end, cnt.getOrDefault(end, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> entry.getValue();<br>            maxBook += freq;<br>            <span class="hljs-keyword">if</span> (maxBook &gt; <span class="hljs-number">2</span>) &#123;<br>                cnt.put(start, cnt.getOrDefault(start, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                cnt.put(end, cnt.getOrDefault(end, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarTwo</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        节点类</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>            <span class="hljs-type">int</span> ls, rs, add, max;   <span class="hljs-comment">// ls, rs 为左右子节点在tr中索引(触手); add 懒标记; max 维护区间最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>, M = <span class="hljs-number">120010</span>, cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// N 区间范围; M 节点个数; cnt 节点在tr中的索引</span><br>        Node[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[M];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarTwo</span><span class="hljs-params">()</span> &#123;<br>            tr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">// 创建根节点</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        更新区间[l,r] 值为val</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-comment">// [l,r]完全覆盖了u表示的区间</span><br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) &#123;<br>                tr[u].add += val;   <span class="hljs-comment">// 懒标记要累计(例如覆盖了2次)</span><br>                <span class="hljs-comment">// 最大值是max(curVal,curVal+val)=curVal+val -&gt; max += val;</span><br>                tr[u].max += val;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束</span><br>            &#125;<br>            <span class="hljs-comment">// 否则</span><br>            lazyCreate(u);  <span class="hljs-comment">// 动态开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) update(tr[u].ls, lc, mid, l, r, val); <span class="hljs-comment">// 尝试更新左子树</span><br>            <span class="hljs-keyword">if</span> (r &gt; mid) update(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r, val);  <span class="hljs-comment">// 尝试更新右子树</span><br>            pushUp(u);  <span class="hljs-comment">// 回溯最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">       查询区间[l,r]的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) <span class="hljs-keyword">return</span> tr[u].max;<br>            lazyCreate(u);  <span class="hljs-comment">// 冬天开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>, res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) res = query(tr[u].ls, lc, mid, l, r);<br>            <span class="hljs-keyword">if</span> (r &gt; mid) res = Math.max(res, query(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r));   <span class="hljs-comment">// 记得取左右子节点的最大值</span><br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        按需动态开点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-keyword">if</span> (tr[u].ls == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 左子节点不存在 -&gt; 创建并构建连接</span><br>                tr[u].ls = cnt++;<br>                tr[tr[u].ls] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tr[u].rs == <span class="hljs-number">0</span>) &#123;<br>                tr[u].rs = cnt++;<br>                tr[tr[u].rs] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        下传懒标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> tr[u].add;  <span class="hljs-comment">// 节点u下传下来的懒标记</span><br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 当且仅当懒标记不为0才进行下传</span><br>                <span class="hljs-comment">// 下传懒标记至子节点(累计)</span><br>                tr[tr[u].ls].add += v;<br>                tr[tr[u].rs].add += v;<br>                <span class="hljs-comment">// 更新左右子节点的值(累计)</span><br>                tr[tr[u].ls].max += v;<br>                tr[tr[u].rs].max += v;<br>                tr[u].add = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 下传懒标记完成撤销u的懒标记</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        回溯更新u的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            tr[u].max = Math.max(tr[tr[u].ls].max, tr[tr[u].rs].max);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>            <span class="hljs-comment">// 最大值&gt;=2说明区间[start,end-1]存在某个点覆盖了2次</span><br>            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            update(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>线段树辅助理解，假设现在范围是0到10，向其中插入4到9，每个数字分别 + 1<br><img src="http://47.108.181.185:7308/20220719.png" alt="线段树插入"></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2022/07/18/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/18/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>一句话描述：适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>系统只能调用A接口，但是现在期望A接口要兼容B接口的功能的时候</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>系统以前只通过mysqlDriver接口连接数据库，但是现在要额外去连接新的数据库，而且新的接口已经开发好了。<br>但是因为大量使用了以前的接口，不好修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 老接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">mysqlDriver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span>;<br>&#125;<br><span class="hljs-comment">// 新接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">newDriver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span>;<br>&#125;<br><span class="hljs-comment">// 新接口的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">oracleDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">newDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 新接口的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">postgresqlDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">newDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectPostgresql</span><span class="hljs-params">(String dbName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOracle</span><span class="hljs-params">(String dbName)</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newDriverAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">mysqlDriver</span>&#123;<br>    newDriver newDriver;<br>    newDriverAdapter(String dbName) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;postgresql&quot;</span>.equals(dbName)) &#123;<br>            newDriver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">postgresqlDriverImpl</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;oracle&quot;</span>.equals(dbName)) &#123;<br>            newDriver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">oracleDriverImpl</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;postgresql&quot;</span>.equals(dbName)) &#123;<br>            newDriver.connectPostgresql(dbName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;oracle&quot;</span>.equals(dbName)) &#123;<br>            newDriver.connectOracle(dbName);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 修改老接口的实现类,调用适配器完成工作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mysqlDriverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">mysqlDriver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String dbName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;mysql&quot;</span>.equals(dbName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;connect to &quot;</span> + dbName);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">newDriverAdapter</span> <span class="hljs-variable">newDriverAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">newDriverAdapter</span>(dbName);<br>            newDriverAdapter.connect(dbName);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">mysqlDriverImpl</span> <span class="hljs-variable">mysqlDriver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">mysqlDriverImpl</span>();<br>        mysqlDriver.connect(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        mysqlDriver.connect(<span class="hljs-string">&quot;oracle&quot;</span>);<br>        mysqlDriver.connect(<span class="hljs-string">&quot;postgresql&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//        connect to mysql </span><br><span class="hljs-comment">//        connect to oracle</span><br><span class="hljs-comment">//        connect to postgresql</span><br></code></pre></td></tr></table></figure><p>以上就达到了完全不需要更改使用到老接口的位置，只需要在实现类中新增适配器的调用就能达到目标</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>不能过多使用，否则整个系统看上去就很乱，后续开发也会很麻烦</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>适配器模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>749. 隔离病毒</title>
    <link href="/2022/07/18/%E9%9A%94%E7%A6%BB%E7%97%85%E6%AF%92/"/>
    <url>/2022/07/18/%E9%9A%94%E7%A6%BB%E7%97%85%E6%AF%92/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://47.108.181.185:7308/20220718.jpg" alt="749. 隔离病毒"><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/contain-virus">https://leetcode.cn/problems/contain-virus</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><p>核心思想：<br>1、找出威胁最大的一群病毒，并统计挡板数量<br>2、最大的那群全部隔离，置为-1<br>3、剩下的病毒全部扩散一次<br>然后重复这个步骤直到结束</p><p>难吧，也没多难…就是是真的很费时间啊</p><p>可以把mark的方法再抽取出来，还有mark数组可以优化成全部公用一个boolean数组，等等，懒得优化代码了XD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] direction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> g;<br>    <span class="hljs-type">int</span>[][] markD;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">containVirus</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> isInfected[<span class="hljs-number">0</span>].length, y = isInfected.length;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">3</span>] - a[<span class="hljs-number">3</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; y; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; x; j++) &#123;<br>                <span class="hljs-comment">// 递归查找标记扩散区域，并记录病毒入口</span><br>                <span class="hljs-keyword">if</span> (isInfected[i][j] == <span class="hljs-number">1</span> &amp;&amp; mark[i][j] != <span class="hljs-number">1</span>) &#123;<br>                    g = <span class="hljs-number">0</span>;<br>                    markD = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mark(isInfected, mark, i, j);<br>                    <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)&#123;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;count, i, j, g&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最大的设墙，其余的扩散</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] first = queue.poll();<br>            result += first[<span class="hljs-number">0</span>];<br>            surround(isInfected, first[<span class="hljs-number">1</span>], first[<span class="hljs-number">2</span>]);<br>            <span class="hljs-type">int</span>[][] mark1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span>[] poll = queue.poll();<br>                <span class="hljs-comment">// 扩散</span><br>                diffusion(isInfected, mark1, poll[<span class="hljs-number">1</span>], poll[<span class="hljs-number">2</span>]);<br>            &#125;<br><br>            <span class="hljs-comment">// 扩散完再确定一次病毒区域</span><br>            <span class="hljs-type">int</span>[][] mark2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; y; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; x; j++) &#123;<br>                    <span class="hljs-comment">// 递归查找标记扩散区域，并记录病毒入口</span><br>                    <span class="hljs-keyword">if</span> (isInfected[i][j] == <span class="hljs-number">1</span> &amp;&amp; mark2[i][j] != <span class="hljs-number">1</span>) &#123;<br>                        g = <span class="hljs-number">0</span>;<br>                        markD = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y][x];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mark(isInfected, mark2, i, j);<br>                        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)&#123;<br>                            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;count, i, j, g&#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span>[][] mark, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        mark[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (markD[ci][cj] == <span class="hljs-number">0</span>) g++;<br>                markD[ci][cj] = <span class="hljs-number">1</span>;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span> &amp;&amp; mark[ci][cj] != <span class="hljs-number">1</span>) &#123;<br>                count += mark(isInfected, mark, ci, cj);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//扩散</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">diffusion</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span>[][] mark, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        mark[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">0</span>) &#123;<br>                mark[ci][cj] = <span class="hljs-number">1</span>;<br>                isInfected[ci][cj] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span> &amp;&amp; mark[ci][cj] != <span class="hljs-number">1</span>) &#123;<br>                diffusion(isInfected, mark, ci, cj);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设为-1</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">surround</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isInfected, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : direction) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i + ints[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j + ints[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ci &lt; <span class="hljs-number">0</span> || ci &gt;= isInfected.length || cj &lt; <span class="hljs-number">0</span> || cj &gt;= isInfected[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInfected[ci][cj] == <span class="hljs-number">1</span>) &#123;<br>                isInfected[ci][cj] = -<span class="hljs-number">1</span>;<br>                surround(isInfected, ci, cj);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记20220715</title>
    <link href="/2022/07/15/%E6%97%A5%E8%AE%B020220715/"/>
    <url>/2022/07/15/%E6%97%A5%E8%AE%B020220715/</url>
    
    <content type="html"><![CDATA[<p>时隔多年再次看三体确实有很多不一样的感受，<br>其中最大的就是，我认为的普通人可能真的不普通</p><p>即使是现在我也认为程心的每个选择都是普通的中立善良形的人会做出的选择，都是可以理解的，这样的人才是大众，也如书中所说，是人类社会选择了程心，选择了带着善意去对待世界。<br>以前我一直以为 因为一个普通人在不普通的故事和不普通的人中间做了普通的事所以招致如此大的厌恶。<br>还是那个想法，如果大多数人都能变成程心至少现在不会让我这么讨厌和人交往。<br>她会因为云天明送的星星感动，会因为发现云天明的真像懊悔，在被全人类推上悬崖的时候接下剑柄，也承担不下毁灭两个星系的来自自己的良心谴责，<br>愿意留在移民地接受战败的人类对她的恶意，觉得自己应该接受惩罚用死让自己好过些，会想着自杀逃避抑郁，会在发现有新的责任的时候放弃寻死，会在基于社会体系感觉人类能活下去的情况下阻止内部战争，<br>会自愿放弃长生归还小宇宙。<br>她做的事当然不全对，但是世界正因为有这样的人才能美好一些，对和错你当然能在事后去评判，但是如果你是叶文洁你真的不会按下发射按钮吗。<br>至少我觉得我会。</p><p>症状并没有好转，我太讨厌现在的人了，因为我是神经病<br>INFJ真的只有1%吗，谁来教教我该怎么在这样的环境下生活，自闭是我永远的归宿</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>735. 行星碰撞</title>
    <link href="/2022/07/13/%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/"/>
    <url>/2022/07/13/%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 asteroids，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p> </p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：asteroids = [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下<span class="hljs-number"> 10 </span>。<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 10 </span>永远不会发生碰撞。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：asteroids = <span class="hljs-comment">[8,-8]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：8 和 -8 碰撞后，两者都发生爆炸。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：asteroids = [10,2,<span class="hljs-string">-5</span>]<br>输出：[10]<br>解释：2 和 <span class="hljs-string">-5</span> 发生碰撞后剩下 <span class="hljs-string">-5</span> 。10 和 <span class="hljs-string">-5</span> 发生碰撞后剩下 10 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/asteroid-collision">https://leetcode.cn/problems/asteroid-collision</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>简单的栈模拟题，写出来很简单，在怎么把代码变短上多花了点时间(乐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        out:<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> asteroid : asteroids) &#123;<br>            <span class="hljs-keyword">if</span> (asteroid &gt; <span class="hljs-number">0</span>) &#123;<br>                deque.addLast(asteroid);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekLast() &lt;= -asteroid) &#123;<br>                <span class="hljs-keyword">if</span> (deque.pollLast() == -asteroid) <span class="hljs-keyword">continue</span> out;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peekLast() &lt; <span class="hljs-number">0</span>) deque.addLast(asteroid);<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[deque.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty()) result[i++] = deque.pollFirst();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>早上出门时心情真的很好，但自</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>741. 摘樱桃</title>
    <link href="/2022/07/12/%E6%91%98%E6%A8%B1%E6%A1%83/"/>
    <url>/2022/07/12/%E6%91%98%E6%A8%B1%E6%A1%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p><p>0 表示这个格子是空的，所以你可以穿过它。<br>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。<br>-1 表示这个格子里有荆棘，挡着你的路。<br>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p><p>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；<br>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；<br>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；<br>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">示例 <span class="hljs-number">1</span>:<br><br>输入: grid =<br><span class="hljs-string">[[0, 1, -1],</span><br><span class="hljs-string">[1, 0, -1],</span><br><span class="hljs-string">[1, 1,  1]]</span><br>输出: <span class="hljs-number">5</span><br>解释：<br>玩家从（<span class="hljs-number">0</span>,<span class="hljs-number">0</span>）点出发，经过了向下走，向下走，向右走，向右走，到达了点(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)。<br>在这趟单程中，总共摘到了<span class="hljs-number">4</span>颗樱桃，矩阵变成了<span class="hljs-string">[[0,1,-1],[0,0,-1],[0,0,0]]</span>。<br>接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了<span class="hljs-number">1</span>颗樱桃。<br>在旅程中，总共摘到了<span class="hljs-number">5</span>颗樱桃，这是可以摘到的最大值了。<br></code></pre></td></tr></table></figure><p>说明:<br>grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;= N &lt;= 50。<br>每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。<br>可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cherry-pickup">https://leetcode.cn/problems/cherry-pickup</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>一开始想着用dfs去做，嗯，要走两次，时间复杂度爆炸，就算逻辑是对的，但是根本过不去<br>动态规划我想不出来怎么写，直接一个cv</p><p>1.第二次回归的路程可以看做是从左上角再走一次，也就是两个人同时从原点出发，按自己的路线走一遍，然后<br>统计摘到的樱桃的最大值。<br>也就是f[x1][y1][x2][y2]，同时出发，所以每一步都有四种可能性，f的值等于上一步所有合法值里最大的值，<br>至于为什么可以dp，因为只能从一个方向走，不能回退，也就有无后效性，到达每一个状态的最优路线是可以被枚举的。</p><p>2.有了第一步的分析，就可以推第二步，设每一回合为k，则x1 + y1 = k = x2 + y2恒成立<br>可以把dp数组缩减一维到f[k][x1][x2],每个位置的坐标就是 (x1, k - x1) 和 (x2, k - x2)</p><p>取自三叶佬：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">55</span>, INF = Integer.MIN_VALUE;  <span class="hljs-comment">// N 为本题范围，因题目有负值的格子，定义INF作为dp数组初始化用</span><br>    <span class="hljs-comment">// 定义dp数组用于记录结果，由题意，第二次遍历等价于与第一次相同的规则再走一遍，故总共有2N次结果。</span><br>    <span class="hljs-comment">// 进而可以将问题转换为，两个点从左上角同时开始走，最后都走到右下角的最大得分。</span><br>    <span class="hljs-comment">// dp[k][i1][i2]为当前已走了k步（k 为所在格子的横纵坐标之和），第一个点在i1行，第二个点在i2行的最大得分，最终答案为dp[2n][n][n]。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * N][N][N];  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-comment">// 初始化dp数组为INF</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">2</span> * n; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt;= n; i1++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i2 &lt;=n; i2++) &#123;<br>                    dp[k][i1][i2] = INF;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp[2][1][1] 两个点都在左上角的初始状态，都为0，即 dp[2][1][1] = grid[0][0]</span><br>        dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 从k=3开始，第一个点开始运动。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; k &lt;= <span class="hljs-number">2</span> * n; k++) &#123;<br>            <span class="hljs-comment">// 两个点都从第一行开始，i1和i2都为1到n。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i1 &lt;= n; i1++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i2 &lt;= n; i2++) &#123;<br>                    <span class="hljs-comment">// 计算两个点当前所在的列</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> k - i1, j2 = k -i2;<br>                    <span class="hljs-comment">// 检查越界</span><br>                    <span class="hljs-keyword">if</span> (j1 &lt;= <span class="hljs-number">0</span> || j1 &gt; n || j2 &lt;= <span class="hljs-number">0</span> || j2 &gt; n) <span class="hljs-keyword">continue</span>; <br>                    <span class="hljs-comment">// 检查两个点所在位置是否有障碍，有的话跳过。</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> grid[i1 - <span class="hljs-number">1</span>][j1 - <span class="hljs-number">1</span>], B = grid[i2 - <span class="hljs-number">1</span>][j2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (A == -<span class="hljs-number">1</span> || B == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 确认两个点同时移动都可行，当前第k步可以从原来的两个点状态的最大值转移过来，由于从行走或从列走都有可能，共有四种状态。</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]; <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dp[k - <span class="hljs-number">1</span>][i1][i2];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(Math.max(a, b), Math.max(c, d)) + A;<br>                    <span class="hljs-comment">// 两个点不重合可以同时累加。</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += B;<br>                    <span class="hljs-comment">// 填入现在最佳的结果。</span><br>                    dp[k][i1][i2] = t;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span> * n][n][n] &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[<span class="hljs-number">2</span> * n][n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式和代理模式</title>
    <link href="/2022/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>非常想把这俩一起说，主要是因为真的太像了。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>它可以不改变现有对象的结构，并且添加新的功能，其实就是作为现有类的一个包装。<br>可以不创建过多的子类重写方法，简单的对一两个方法进行增强。<br>1、创建包装器的抽象类，实现装饰对象的接口，内部加一个装饰对象的成员变量，通过构造器传入参数赋值到成员变量上<br>2、造一个包装器的实现类，实现装饰对象的方法，在实现的方法中通过成员变量调用装饰对象的原本的方法，这样在这个调用的前后，就可以做一些方法上的增强<br>3、创建包装器的对象，调用包装器的方法</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式主要是提供一个中间层控制对对象的访问，<br>在代理对象执行目标方法的时候也可以对方法进行增强，比如执行完一个方法之后打印日志、执行查询数据库前切换到对应数据源之类的操作</p><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><p>相似之处就是都能对目标方法做增强。<br>最主要的区别在于：<br>代理模式是控制对目标的访问，在前后做一些增强处理，没有改变对象本身的能力，装饰器模式是让对象本身能做更多的事了</p><p>打个比方：<br>去一个饭店吃饭，我只知道要让厨师做我想吃的菜<br>代理模式：雇了个服务员，服务员点餐-&gt;厨师做菜-&gt;服务员送菜，厨师对客人来说被隐藏了，厨师还是只知道做菜，其余的交给服务员做<br>装饰器模式：厨师通过锻炼变成了超人厨师，自己点餐，自己做菜，自己送菜，</p><h3 id="装饰器模式示例"><a href="#装饰器模式示例" class="headerlink" title="装饰器模式示例"></a>装饰器模式示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java">步骤 <span class="hljs-number">1</span><br>创建一个接口：<br><br>Shape.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br>步骤 <span class="hljs-number">2</span><br>创建实现接口的实体类。<br><br>Rectangle.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Shape: Rectangle&quot;</span>);<br>   &#125;<br>&#125;<br>Circle.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Shape: Circle&quot;</span>);<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">3</span><br>创建实现了 Shape 接口的抽象装饰类。<br><br>ShapeDecorator.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">protected</span> Shape decoratedShape;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span>&#123;<br>      <span class="hljs-built_in">this</span>.decoratedShape = decoratedShape;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>      decoratedShape.draw();<br>   &#125;  <br>&#125;<br>步骤 <span class="hljs-number">4</span><br>创建扩展了 ShapeDecorator 类的实体装饰类。<br><br>RedShapeDecorator.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedShapeDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ShapeDecorator</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span> &#123;<br>      <span class="hljs-built_in">super</span>(decoratedShape);     <br>   &#125;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>      decoratedShape.draw();         <br>      setRedBorder(decoratedShape);<br>   &#125;<br> <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRedBorder</span><span class="hljs-params">(Shape decoratedShape)</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Border Color: Red&quot;</span>);<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">5</span><br>使用 RedShapeDecorator 来装饰 Shape 对象。<br><br>DecoratorPatternDemo.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPatternDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>      <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>      <span class="hljs-type">ShapeDecorator</span> <span class="hljs-variable">redCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>      <span class="hljs-type">ShapeDecorator</span> <span class="hljs-variable">redRectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>      <span class="hljs-comment">//Shape redCircle = new RedShapeDecorator(new Circle());</span><br>      <span class="hljs-comment">//Shape redRectangle = new RedShapeDecorator(new Rectangle());</span><br>      System.out.println(<span class="hljs-string">&quot;Circle with normal border&quot;</span>);<br>      circle.draw();<br> <br>      System.out.println(<span class="hljs-string">&quot;\nCircle of red border&quot;</span>);<br>      redCircle.draw();<br> <br>      System.out.println(<span class="hljs-string">&quot;\nRectangle of red border&quot;</span>);<br>      redRectangle.draw();<br>   &#125;<br>&#125;<br>步骤 <span class="hljs-number">6</span><br>执行程序，输出结果：<br><br>Circle with normal border<br>Shape: Circle<br><br>Circle of red border<br>Shape: Circle<br>Border Color: Red<br><br>Rectangle of red border<br>Shape: Rectangle<br>Border Color: Red<br>示例来源：https:<span class="hljs-comment">//www.runoob.com/design-pattern/decorator-pattern.html</span><br></code></pre></td></tr></table></figure><h3 id="代理模式示例"><a href="#代理模式示例" class="headerlink" title="代理模式示例"></a>代理模式示例</h3><p>jdk的动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) Proxy.newProxyInstance(UserProxyTest.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;User.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserImpl</span>()));<br>        System.out.println(user.add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>        User user;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(UserImpl user)</span>&#123;<br>            <span class="hljs-built_in">this</span>.user = user;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            System.out.println(<span class="hljs-string">&quot;前置&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(user, args);<br>            System.out.println(<span class="hljs-string">&quot;方法执行&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;后置&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装饰器模式</tag>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>648. 单词替换</title>
    <link href="/2022/07/07/%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"/>
    <url>/2022/07/07/%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>要做的事并没有做完，只是忙到现在实在有点累了，看算法题休息一下</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p><p>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p><p>你需要输出替换之后的句子。</p><blockquote><p>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 100<br>dictionary[i] 仅由小写字母组成。<br>1 &lt;= sentence.length &lt;= 10^6<br>sentence 仅由小写字母和空格组成。<br>sentence 中单词的总量在范围 [1, 1000] 内。<br>sentence 中每个单词的长度在范围 [1, 1000] 内。<br>sentence 中单词之间由一个空格隔开。<br>sentence 没有前导或尾随空格。</p></blockquote><p>示例 1：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：dictionary = [<span class="hljs-comment">&quot;cat&quot;</span>,<span class="hljs-comment">&quot;bat&quot;</span>,<span class="hljs-comment">&quot;rat&quot;</span>], sentence = <span class="hljs-comment">&quot;the cattle was rattled by the battery&quot;</span><br>输出：<span class="hljs-comment">&quot;the cat was rat by the bat&quot;</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/replace-words">https://leetcode.cn/problems/replace-words</a></p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>我自己放空大脑靠直觉写的模拟解法,给字典排个序，然后对每个字符从头开始从字典里找存不存在，存在就替换就行<br>String的api真好用(</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        dictionary.sort((a, b) -&gt; a.length() - b.length());<br>        String[] splits = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; splits.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (String s : dictionary) &#123;<br>                <span class="hljs-keyword">if</span> (splits[i].startsWith(s)) &#123;<br>                    splits[i] = s;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, splits);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>很明显也能构建字典树的方式去查，树形结构，在加上是否尾节点的判断。<br>然后每个单词按照树依次查就行，理论上是这题里最快的解法，摸了半小时该继续了，贴个三叶大佬的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">boolean</span> isEnd;<br>        Node[] tns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u] == <span class="hljs-literal">null</span>) p.tns[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            p = p.tns[u];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    String <span class="hljs-title function_">query</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (p.tns[u].isEnd) <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>            p = p.tns[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; ds, String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : ds) add(str);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String str : s.split(<span class="hljs-string">&quot; &quot;</span>)) sb.append(query(str)).append(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/replace-words/solution/by-ac_oier-jecf/</span><br>来源：力扣（LeetCode）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记20220706</title>
    <link href="/2022/07/06/%E6%97%A5%E8%AE%B020220706/"/>
    <url>/2022/07/06/%E6%97%A5%E8%AE%B020220706/</url>
    
    <content type="html"><![CDATA[<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>忙起来时间过得确实很快，这几天的力扣题也没怎么做。<br>总算是暂时忙完一下，可以快乐摸鱼了()<br>就我一个人，用自己操作原生jdbc去实现一个网络接口版本的dataX属实是不可能，最后的实现方案是通过切换数据源拿到表结构，<br>然后根据表结构代码生成器生成PO字符串，然后用groovy动态得把PO加载成class类，用反射和集成的ORM框架去处理不同数据库数据类型的关系，<br>然后接下来就是熟悉的增删改查环节。</p><p>一步十坑呐，这段时间真的焦虑死我，在家都想着怎么改bug</p><p>juc之前又复习了一遍，这么多遍下来也算是能背了。<br>寻思着学点什么，果然还是消息队列，设计模式倒是一直有在看，之后专门出一个分类写笔记吧。</p><p>追加：看来接下来这三天又要写前端代码了，也罢，好好复习下js吧，以后说不定要去搞nodejs开发</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>昨天难得的睡了七个半小时，感觉现在身体状态还不错，买的人体工学椅也是今天到，希望有效…<br>嗯，我FF14不打算开荒龙诗了。 一方面是武器不是很喜欢，一方面是开荒则必然时间会在二十五到三十多天，每天晚上都要三个小时<br>最近我的心理情况也不允许我做这么大的投入，中途自己崩溃了退出，对队友也不负责。<br>就每次更新打打剧情，开荒首周零式就行，一个版本也就投入五十小时不到。</p><p>在重看三体，主要是我自己愈发严重的对人的厌恶和对人类的喜爱让我想起了这本书</p><p>板绘在练着，头部的透视，然后带上脸谱的透视，然后再加上头发，手部的透视，然后肝一个带景人物线稿，然后…去学色彩部分。</p><p>所以我是社恐不是自闭，我没法把别人当不存在，反而是太过在意其他人了，所以想逃离所有人。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘画20220703</title>
    <link href="/2022/07/03/%E7%BB%98%E7%94%BB20220703/"/>
    <url>/2022/07/03/%E7%BB%98%E7%94%BB20220703/</url>
    
    <content type="html"><![CDATA[<p><img src="http://47.108.181.185:7308/D20220703.png" alt="透视练习"></p><p>…菜菜的透视练习，下一个练头部吧</p>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
      <category>透视</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记20220630</title>
    <link href="/2022/06/30/%E6%97%A5%E8%AE%B020220630/"/>
    <url>/2022/06/30/%E6%97%A5%E8%AE%B020220630/</url>
    
    <content type="html"><![CDATA[<p>现在就感觉自己很虚无啊…</p><p>你说那些技术学是学了，平时工作又用不到，那么就会开始忘，毕竟要背要记的还是很多的。<br>等到忘得差不多了，其实用去学习所消耗的所有时间只做到了一件事：知道某个技术是干啥的，记得一些重点的大概的模糊的感觉。</p><p>学完nio和netty，现在就只记得高性能网络编程框架，基于选择器管道和缓冲的非阻塞io实现，然后呢，平时都做的传统web应用，<br>现在能不复习不看参考从零写个接口吗，不太行，两个月过去api都快忘光了(´；ω；`)</p><p>学完mysql底层，哦哦，表结构、行结构、一页16kb，分段，mvcc，redo，undo，binlog，我可太有映象了，那详细说说？<br>…我又不是去参加什么考试，一工作上用不到这么细，二又不做题不考试，哪全背得。</p><p>那…为啥要对暂时用不到的技术投入那么多时间呢。<br>我大可以各种技术每种都去简单了解下背景，是什么，干什么，能做到什么，能解决什么问题，然后写一些简单的helloworld，<br>到这一步就够了，留下映象，等要用了再去深入学不迟。</p><p>感觉自己好像会的还蛮多的，但是感觉自己好像什么都不会，就感觉学医的都是神仙，那么多书是怎么背下来的，<br>别说月，学完半个月不用我就开始忘了。</p><p>比起上层技术，果然还是有时间不如扎实的去学习巩固下层基础。</p><p>过一遍racketMQ继续去学习设计模式和jvm</p><p>就感觉一切都怪那些培训机构、公众号、内卷面试天天散播焦虑。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>522. 最长特殊序列 II</title>
    <link href="/2022/06/30/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/"/>
    <url>/2022/06/30/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定字符串列表 strs ，返回其中 最长的特殊序列 的长度。如果最长特殊序列不存在，返回 -1 。</p><p>特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。</p><p>s 的 子序列可以通过删去字符串 s 中的某些字符实现。</p><p>例如，”abc” 是 “aebdc” 的子序列，因为您可以删除”aebdc”中的下划线字符来得到 “abc” 。”aebdc”的子序列还包括”aebdc”、 “aeb” 和 “” (空字符串)。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii">https://leetcode.cn/problems/longest-uncommon-subsequence-ii</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>题目很绕，但是其实如果一个字符串str，他本身不是特殊序列，那么所有他的子串都不可能是特殊序列。<br>因为他本身都出现过了，那么子串必然也出现过。<br>再反过来想，如果一个字符串的任何一个子串是特殊序列，那么不管在子串上加多少字符必然都是特殊序列。</p><p>所以这题就变成了：挨个去判断str是不是其他字符串的子序列。<br>然后找出符合条件的str里最长的那个的长度</p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        mm:<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].length() &gt; ans) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; strs.length; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (j != i &amp;&amp; isSubStr(strs[i], strs[j])) &#123;<br>                        <span class="hljs-keyword">continue</span> mm;<br>                    &#125;<br>                &#125;<br>                ans = strs[i].length();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStr</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length(), n = s2.length();<br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>= m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><p>同样的也可以转化成lcs问题，判断一个字符串a和字符串b中的最长公共子序列的长度len，如果len等于a的长度，那么a就是b的一个子序列<br>基本LCS问题: <a href="http://shinone.cn/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/">http://shinone.cn/2022/06/30/最长公共子序列/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].length() &lt;= ans) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; ok; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (check(strs[i], strs[j])) ok = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ok) ans = strs[i].length();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length(), m = s2.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                f[i][j] = s1.charAt(i - <span class="hljs-number">1</span>) == s2.charAt(j - <span class="hljs-number">1</span>) ? f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                f[i][j] = Math.max(f[i][j], f[i - <span class="hljs-number">1</span>][j]);<br>                f[i][j] = Math.max(f[i][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (f[i][j] == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>作者：AC_OIer<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>LCS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143. 最长公共子序列</title>
    <link href="/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：text1 = <span class="hljs-string">&quot;abcde&quot;</span>, text2 = <span class="hljs-string">&quot;ace&quot;</span><br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-common-subsequence">https://leetcode.cn/problems/longest-common-subsequence</a></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> text1.length(),l2 = text2.length();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[l1 + <span class="hljs-number">1</span>][l2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= l1 ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= l2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[l1][l2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>f[i][j]的定义是只考虑到t1的前i个字符和t2的前j个字符，<br>最长的公共子序列是多长。<br>状态转移方程就是，如果新增的字符相等，则最长子序列等于只考虑i-1 和 j-1时的最长长度 + 1；<br>如果新增的字符不相等，则选择不考虑t1的前一个字符或者不考虑t2的前一个字符里更长的那个。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>LCS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>324. 摆动排序 II</title>
    <link href="/2022/06/29/%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8FII/"/>
    <url>/2022/06/29/%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8FII/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol start="324"><li>摆动排序 II<br>给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。<br>你可以假设所有输入数组都可以得到满足题目要求的结果。</li></ol><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>解释：[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>] 同样是符合题目要求的结果，可以被判题程序接受。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/wiggle-sort-ii/">https://leetcode.cn/problems/wiggle-sort-ii/</a></p><h1 id="快速选择-三路分治-虚拟地址"><a href="#快速选择-三路分治-虚拟地址" class="headerlink" title="快速选择+三路分治+虚拟地址"></a>快速选择+三路分治+虚拟地址</h1><p>来自三叶大佬的题解，只是看懂了而已，并不是我能做得出来的难度…<br>要达到On时间复杂度和O1的空间复杂度是真的…好难啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qselect</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) swap(i, j);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= cnt) <span class="hljs-keyword">return</span> qselect(l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> qselect(j + <span class="hljs-number">1</span>, r, k - cnt);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = c;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>) % (n | <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wiggleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums)</span> &#123;<br>        nums = _nums;<br>        n = nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> qselect(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, loc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (loc &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[getIdx(loc)] &gt; x) swap(getIdx(loc++), getIdx(l++));<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[getIdx(loc)] &lt; x) swap(getIdx(loc), getIdx(r--));<br>            <span class="hljs-keyword">else</span> loc++;<br>        &#125;<br>    &#125;<br>&#125;<br>作者：AC_OIer<br></code></pre></td></tr></table></figure><p>首先肯定是考虑排个序一个大一个小直接开摆就行，但是会出现这种问题:<br>412321排序：112234<br>一个大一个小：413122，然后挂了<br>必须要把中间的2，分到互相远离的地方，也就是：423121 这样才行<br>而且排序的复杂度是nlogn</p><p>首先快速选择算法 On复杂度找到中位数：2<br>然后三路分治排序复杂度是On：小于2的放左边等于2的放中间大于2的放右边 可能是112234也可能是112243</p><p>最后这步，可以用复制一个数组的方式摆，但是空间复杂度就会是On，要降为O1就需要用虚拟地址的方式进行第二步的三路分治<br>也就是写一个函数f(x) -&gt; y<br>x = 0 (1), y = 1<br>x = 1 (1), y = 3<br>x = 2 (2), y = 5<br>x = 3 (2), y = 0<br>x = 4 (3), y = 2<br>x = 5 (4), y = 4<br>排序逻辑正常按照x的值排序，但是实际交换是交换的f(x)的地址，达到错开的效果<br>理论上排序之后的结果：112234<br>实际结果：213142</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速选择</tag>
      
      <tag>虚拟地址</tag>
      
      <tag>三路分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 091. 粉刷房子</title>
    <link href="/2022/06/29/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/2022/06/29/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: costs = <span class="hljs-string">[[17,2,17],[16,16,5],[14,3,19]]</span><br>输出: <span class="hljs-number">10</span><br>解释: 将 <span class="hljs-number">0</span> 号房子粉刷成蓝色，<span class="hljs-number">1</span> 号房子粉刷成绿色，<span class="hljs-number">2</span> 号房子粉刷成蓝色。<br>最少花费: <span class="hljs-number">2</span> + <span class="hljs-number">5</span> + <span class="hljs-number">3</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/JEj789">https://leetcode.cn/problems/JEj789</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] cs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> cs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b = cs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], c = cs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.min(b + cs[i][<span class="hljs-number">0</span>], c + cs[i][<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> Math.min(a + cs[i][<span class="hljs-number">1</span>], c + cs[i][<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Math.min(a + cs[i][<span class="hljs-number">2</span>], b + cs[i][<span class="hljs-number">2</span>]);<br>            a=d; b = e; c = f;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(Math.min(a, b), c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记最后一栋房子刷abc三种油漆的总价分别为Ca Cb Cc，第i号房子刷的油漆价格为ai bi ci。</p><p>已知房子0，刷三种颜色的油漆分别需要a0(cs[0][1])、b0(cs[0][2])、c0(cs[0][3])<br>这时候的总价为 Ca = a0, Cb = b0, Cc = c0;</p><p>房子0 + 房子1 刷每种油漆的价格最低的总价计算方式：<br>因为房子颜色不能重复，房子1 要刷a颜料，那么就只能a1加上上一栋房子，也就是房子0的b和c颜料这俩里价格更低的那个:<br>Ca = Min(a1 + Cb, a1 + Cc);<br>意思就是房子1刷a颜料，考虑到房子0，总价的最低价格是多少；<br>依次算出Cb和Cc，然后保持这个计算方式推完所有房子；<br>到最后一栋房子的时候得到三个最低总价，取三个中最低的那个就是最后的答案。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>535. tinyurl的加密与解密</title>
    <link href="/2022/06/29/tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    <url>/2022/06/29/tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a> 。请你设计一个类来加密与解密 TinyURL 。</p><p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p><p>实现 Solution 类：</p><p>Solution() 初始化 TinyURL 系统对象。<br>String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。<br>String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/encode-and-decode-tinyurl">https://leetcode.cn/problems/encode-and-decode-tinyurl</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h1><p>首先要保证长url不管加密多少次都会得到相同的短url，<br>然后要保证一个短url一定对应原有的长url；</p><h1 id="无为而治"><a href="#无为而治" class="headerlink" title="无为而治"></a>无为而治</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String longUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> longUrl;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String shortUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> shortUrl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好，我答完了（草）</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; origin2Tiny = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>), tiny2Origin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://shinone.com/&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">K</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String longUrl)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!origin2Tiny.containsKey(longUrl)) &#123;<br>            <span class="hljs-type">char</span>[] cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[K];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; K; i++) cs[i] = str.charAt(random.nextInt(str.length()));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prefix + String.valueOf(cs);<br>            <span class="hljs-keyword">if</span> (tiny2Origin.containsKey(cur)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">synchronized</span> (Codec.class) &#123;<br>                <span class="hljs-keyword">if</span> (tiny2Origin.containsKey(cur)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (!origin2Tiny.containsKey(longUrl)) &#123;<br>                    tiny2Origin.put(cur, longUrl);<br>                    origin2Tiny.put(longUrl, cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> origin2Tiny.get(longUrl);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String shortUrl)</span> &#123;<br>        <span class="hljs-keyword">return</span> tiny2Origin.get(shortUrl);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当工具类用不加锁会出大问题<br>单体应用好像可以这么搞，分布式的话得弄个缓存当哈希表用，还可以设置超时时间。<br>单体要弄超时的话就把value再封装进一个类里，然后不主动去删除，在每次判断包含不包含的时候，再额外判断一次是否超时，超时了就可以覆盖掉就行。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>tinyurl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待填坑事项</title>
    <link href="/2022/06/28/%E5%BE%85%E5%A1%AB%E5%9D%91%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/06/28/%E5%BE%85%E5%A1%AB%E5%9D%91%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h1><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p>说好的把所有听的歌的音源整理之后存云盘上，结果现在进度只有七分之一，怎么辉石呢</p>]]></content>
    
    
    <categories>
      
      <category>挖坑不埋</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记20220628</title>
    <link href="/2022/06/28/%E6%97%A5%E8%AE%B020220628/"/>
    <url>/2022/06/28/%E6%97%A5%E8%AE%B020220628/</url>
    
    <content type="html"><![CDATA[<p>闲的时候闲一天，忙的时候突然来一堆需求。<br>高强度工作两天了，完全没时间摸鱼做力扣(不是)<br>主要下班之后不太想写算法题啊，脑子都嗡嗡的。</p><p>为什么每天早上会这么痛苦呢…<br>生理上腰酸背疼，恶心反胃，拖着重重的身子上班。<br>心理上，生无可恋，害怕即将到来的一天。</p><p>反倒是开始上班了，开始敲代码就不会想那些有的没的，有事情的时候时间过得飞快，一下一天就结束了。</p><p>这两天倒是在项目上练了下以前一般不会接触的东西，<br>比如在服务运行时动态编译装载class类对象，然后调用orm框架根据生成的对象操作数据库<br>、AES对称加密<br>、自定义定时任务，创建暂停删除那些</p><p>…还是很难受，今天又掉进里世界，整个人在里面害怕、自卑了好一阵，临近下班才好些，我还是太菜了。</p><p>希望今晚能有点动力肝一下进度。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记20220625</title>
    <link href="/2022/06/25/%E6%97%A5%E8%AE%B020220625/"/>
    <url>/2022/06/25/%E6%97%A5%E8%AE%B020220625/</url>
    
    <content type="html"><![CDATA[<blockquote><p>要向远方行走，首先得知道来处</p></blockquote><p>记忆已经很模糊了，我只记得三年级的时候，什么都没跟我说，把我骗去老家的学校说是参观，这一参观<br>我就在那度过了整个小学，原来转校手续什么的全都瞒着我办完了。上学日住在老师家里，周末住在教书的外婆家里，半个月回次家，离家七十公里<br>自己做大巴车，然后转两趟公交回家，偶尔父母能开车来接我会很高兴。六年级之后小升初考试，更是每周都坐回家去<br>上补习班，为了不在老家，回昆明，回家。<br>我现在也都还记得只是因为没考到90分被老师赶出教室，在走廊上哭一个上午，然后转班去外婆教的班。道理我都懂，为了我好嘛，我是乖孩子。<br>住老师家，住外婆家，住同学家，住亲戚家，就感觉自己像个孤儿一直在外面飘，有家不能回，<br>我为什么这么喜欢察言观色，一直也没啥安全感，大概就是小时候为了生存一直保持下来的习惯。<br>而且我真的很讨厌老家，如果长辈走了，以后再也不会回去了。</p><p>初中终于考到云大附中了呢，学号七号呢，也终于没人管我了呢，但是并没能回家，依然是住校。<br>我好孩子装给谁看呢，然后累了摆了，差点没考上高中。<br>中考前一周末我还网吧通宵了三天累到记忆断片倒在宿舍床上，初中三年活的像个小丑，疯疯癫癫。<br>父母觉得是我性格问题，找了大师算了一卦，瞒着我给我找了个干爹，说什么克冲，我也不在意。<br>虽然物理化学都九十多，只是因为自己感兴趣而已，其他基本全挂。<br>虽然老师们都挺好的，但是我不想自己好，还是感觉有点对不住英语和地理老师。</p><p>因为摆了，志愿都没自己填，没录上，托关系给我弄去国际班，以后出国什么的，乐，真是病急乱投医。那时候我大概是感觉有点对不住父母，<br>又是借读又是转校，兜兜转转回了老家，有意思吗，没意思。然后我玩了三年，进了本地的二本，玩了四年，没考上研，然后开始工作了。<br>也算我运气好没被怎么霸凌，毕竟跟真正的霸凌比起来都算是过家家吧，毕竟亲戚都是老师，没敢怎么过分。<br>初中之后到大学毕业真的是浑浑噩噩，只是把自己当个过客，人名都没记住几个，我为啥没继续摆了变成这般焦虑的鬼样子，大概是大学毕业之后突然觉得有点对不住自己。</p><p>虽然说从现在开始都不算晚，可惜终究还是有点晚了。</p><p>然后我突然就懂了，原来我一直都活在歉意里，即使写这些话看着像是在诉苦。我一直活在小时候的阴影里没走出来，<br>直到现在依然胸口空空的，从没真正地感受过安心，<br>可能这辈子都走不出来。我不喜欢人，不喜欢交流，很少说话，自卑自责，畏手畏脚都有迹可循，我确实不会为人处世，因为我根本就不想入世。</p><p>说了这么多，我倒也没怪父母，依然很感谢他们，现在家里关系也挺和睦的，也真的很感谢六外婆，这几年可能就拜访了两三次，到底还是觉得有点对不住她。毕竟是父母求的人情，我又有什么办法，说不定会被说白眼狼什么的，但是又觉得我这是小人之心。<br>只是有点累而已，早在很小的时候，随着公交车摇晃的时候就已经有点累了。</p><hr><p>该向前走了，真的很累很烦啊，但是到底还是得去未来看看。<br>连自我都感动不了没泪可流的经历有什么好回顾的，我怎么就不是美少女呢，说不定当初父母会有点不忍心。<br>（乐）</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="/2022/06/24/%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/06/24/%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://47.108.181.185:7308/20220624.png" alt="在每个树行中找最大值"></p><p>来源:<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p><h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.addLast(root);<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size(), max = deque.peek().val;<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> deque.poll();<br>                max = Math.max(poll.val, max);<br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) deque.addLast(poll.left);<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) deque.addLast(poll.right);<br>            &#125;<br>            list.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一直都是用dfs在做，今天这题dfs的话要用一个哈希表维护深度和最大值，感觉有点麻烦，还是bfs吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过配置文件动态过滤springboot的自动装配类</title>
    <link href="/2022/06/24/%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB/"/>
    <url>/2022/06/24/%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在引入redis做缓存之后，即使在spring.redis.enable配置项上设为false，不启用缓存，依然会自动配置redis的连接，<br>不配置连接就无法正常启动。<br>现在需要通过这个配置项去控制启动项目的时候是否去自动装载redis，在@springbootApplication上exclude无法做到这样的控制。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="新增配置类"><a href="#新增配置类" class="headerlink" title="新增配置类"></a>新增配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfigurationImportFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoConfigurationImportFilter</span>, EnvironmentAware &#123;<br>    <span class="hljs-comment">// 1.实现EnvironmentAware接口，重写setEnvironment方法，获取到配置文件环境变量</span><br>    <span class="hljs-keyword">private</span> Environment environment;<br>    <span class="hljs-comment">// 2.用一个map存储需要判断哪些配置值以及需要剔除的配置类(也可以选择其他方式)</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; filterAutoConfigurationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 3.这里是通过构造方法初始化需要过滤的类，也可以选择其他方式</span><br>    <span class="hljs-comment">// key为配置，value是剔除配置类的全类名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisAutoConfigurationImportFilter</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration&quot;</span>);<br>        filterAutoConfigurationMap.put(<span class="hljs-string">&quot;spring.redis.enable&quot;</span>, list);<br>    &#125;<br>    <span class="hljs-comment">// 4.实现AutoConfigurationImportFilter接口，重写判断逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span>[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;<br>        <span class="hljs-comment">// 需要剔除的类集合</span><br>        Set&lt;String&gt; filterClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 根据配置值判断是否需要剔除</span><br>        filterAutoConfigurationMap.forEach((k, v) -&gt; &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">enableProperty</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.environment.getProperty(k, Boolean.class);<br>            <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(enableProperty)) &#123;<br>                filterClass.addAll(v);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (filterClass.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">boolean</span>[] skip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[autoConfigurationClasses.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; autoConfigurationClasses.length; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">autoConfigurationClass</span> <span class="hljs-operator">=</span> autoConfigurationClasses[i];<br>                <span class="hljs-keyword">if</span> (!filterClass.contains(autoConfigurationClass)) &#123;<br>                    skip[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> skip;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(Environment environment)</span> &#123;<br>        <span class="hljs-built_in">this</span>.environment = environment;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在resource文件夹下新建META-INF文件夹，新建spring-factories文件"><a href="#在resource文件夹下新建META-INF文件夹，新建spring-factories文件" class="headerlink" title="在resource文件夹下新建META-INF文件夹，新建spring.factories文件"></a>在resource文件夹下新建META-INF文件夹，新建spring.factories文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 替换成自己的全类名</span><br><span class="hljs-attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.xxx.xxx.config.RedisAutoConfigurationImportFilter</span><br></code></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在不自动装载redis后，自动注入redisTemplate会报错，如果有配置redisUtil类，可以用@conditionOnProperties控制不自动注册</p><h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><ol><li><p>从spring.factories配置文件中加载自动配置类，在这一步会用LinkedHashSet()去重;</p></li><li><p>加载的自动配置类中排除掉 @EnableAutoConfiguration 注解的 exclude 属性指定的自动配置类；</p></li><li><p>然后再用 AutoConfigurationImportFilter 接口去过滤自动配置类是否符合其标注注解（若有标注的话） @ConditionalOnClass , @ConditionalOnBean 和<br>@ConditionalOnWebApplication 的条件，若都符合的话则返回匹配结果；<br>在这一步spring会从spring.properties中读取所有AutoConfigurationImportFilter接口的实现类，然后用迭代器依次执行match方法，最后得到一个boolen[]</p></li><li><p>然后触发 AutoConfigurationImportEvent，告诉ConditionEvaluationReport条件评估报告器对象来分别记录符合条件和 exclude 的自动配置类。</p></li><li><p>最后spring再将最后筛选后的自动配置类导入IOC容器中</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>自动装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视练习-20220622</title>
    <link href="/2022/06/22/%E7%BB%98%E7%94%BB20220622/"/>
    <url>/2022/06/22/%E7%BB%98%E7%94%BB20220622/</url>
    
    <content type="html"><![CDATA[<p><img src="http://47.108.181.185:7308/D20220622.jpg" alt="场景透视练习"><br>…算是挺久之前的练习了，想初始化一下板绘这边的分类就传上来吧<br>基本上所有物件都是对齐透视方向，旋转、浮空方块、倾斜这些，都完全没有()<br>画的我FF14里的家</p>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
      <category>透视</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>513. 找树左下角的值</title>
    <link href="/2022/06/22/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <url>/2022/06/22/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。<br><img src="http://47.108.181.185:7308/20220622.png" alt="示例"><br><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> deep)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (deep &gt; d) &#123;<br>            result = root.val;<br>            d = deep;<br>        &#125;<br>        dfs(root.left, deep + <span class="hljs-number">1</span>);<br>        dfs(root.right, deep + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>蛮简单的，上次做这道题是21年的7月份，不知不觉一年就过去了啊…</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>508. 出现次数最多的子树元素和</title>
    <link href="/2022/06/20/%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <url>/2022/06/20/%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p>一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[5,2,-3]</span><br>输出: <span class="hljs-comment">[2,-3,4]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[5,2,-5]</span><br>输出: <span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/most-frequent-subtree-sum">https://leetcode.cn/problems/most-frequent-subtree-sum</a></p><h1 id="DFS-哈希"><a href="#DFS-哈希" class="headerlink" title="DFS+哈希"></a>DFS+哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findFrequentTreeSum(TreeNode root) &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        count(root);<br>        ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (e.getValue() == max) arrayList.add(e.getKey());<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arrayList.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; i++) result[i] = arrayList.get(i);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> root.val + count(root.left) + count(root.right);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">orDefault</span> <span class="hljs-operator">=</span> map.getOrDefault(count, <span class="hljs-number">0</span>);<br>        orDefault++;<br>        map.put(count, orDefault);<br>        max = Math.max(max, orDefault);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>532. 数组中的 k-diff 数对</title>
    <link href="/2022/06/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-diff%E6%95%B0%E5%AF%B9/"/>
    <url>/2022/06/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-diff%E6%95%B0%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p><p>k-diff 数对定义为一个整数对 (nums[i], nums[j]) ，并满足下述全部条件：</p><p>0 &lt;= i, j &lt; nums.length<br>i != j<br>nums[i] - nums[j] == k<br>注意，|val| 表示 val 的绝对值。</p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3, 1, 4, 1, 5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：数组中有两个 <span class="hljs-number">2</span>-diff 数对, (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) 和 (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)。<br>尽管数组中有两个 <span class="hljs-number">1</span> ，但我们只应返回不同的数对的数量。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1, 2, 3, 4, 5]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：数组中有四个 <span class="hljs-number">1</span>-diff 数对, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) 和 (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array">https://leetcode.cn/problems/k-diff-pairs-in-an-array</a></p><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>            Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(i - k)) set2.add(i - k);<br>                <span class="hljs-keyword">if</span> (set.contains(i + k)) set2.add(i);<br>                set.add(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> set2.size();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为今天是简单题，闲来无事就把昨天的中等题搬一下…<br>每个数对只统计一次，所以可以直接用第二个哈希表去重。<br>注意点就在于，如果同时存在1 3 5，k = 2的时候，如果只往数组里存i - k 和 i + k 就会出问题。<br>到3的时候因为数组里没有5，所以会存一个重复的1进去， 到5的时候再把3存进去，但是5他自己本身不会存进去的，因为他是最后一个数了。<br>所以得改成存 i - k 和 i 或者 i + k 和 i确保不会出现上面那种情况。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>719.找出第k小的数对距离</title>
    <link href="/2022/06/15/%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/06/15/%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</p><p>给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 &lt;= i &lt; j &lt; nums.length 。返回 所有数对距离中 第 k 小的数对距离。</p><p> </p><p>示例 1：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：数对和对应的距离如下：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br>距离第 <span class="hljs-number">1</span> 小的数对是 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) ，距离为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance">https://leetcode.cn/problems/find-k-th-smallest-pair-distance</a></p><h1 id="排序-二分-双指针"><a href="#排序-二分-双指针" class="headerlink" title="排序 + 二分 + 双指针"></a>排序 + 二分 + 双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestDistancePair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>            Arrays.sort(nums);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums[nums.length - <span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (check(nums, mid) &gt;= k) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= x) j++;<br>                ans += j - i - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例：[1, 6, 1]  k = 3<br>因为题目指出，要排序的是值的绝对差，所以可以先进行一次排序，得到<br>[1, 1, 6]<br>排序后的数列两个元素之间的差就会是一个递增的数列<br>1、这时数列中，一定会存在一个值A一定满足：大于等于这个差值A，必然有数列中任意两个元素的差值B &lt; A 的所有个数,大于等于k<br>如：A=6的个数&gt;=3，A=5的个数也是&gt;=3,即：1-1&lt;6 , 6-1&lt;6, 6-1&lt;6一共三组<br>小于这个差值A，则不一定满足这个条件，如[2, 3, 7] k = 1; mid = (5 + 0) &gt;&gt; 1 = 2,当2为A值的时候刚好个数为1大于等于k<br>2、这时候A的下界是0，上界是最大值减去最小值，也就是6-1 = 5，在这个范围内进行二分查找，最后的A值一定就是题目需要的第k小的值<br>(描述的支离破碎，相信未来的我一定能看懂（）)</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记20220615</title>
    <link href="/2022/06/15/%E6%97%A5%E8%AE%B020220615/"/>
    <url>/2022/06/15/%E6%97%A5%E8%AE%B020220615/</url>
    
    <content type="html"><![CDATA[<p>现在想来 我好像还是没搞懂生活。<br>FF14整个1.0到6.0都在传达：你的人生是一个问题，在生与死的瞬间会获得自己的答案<br>早在两千年前屈原也表示路漫漫其修远兮吾将上下而求索。<br>可能真的生活只是在不断地去寻找答案，永远都在路上，我一直在想怎么去活才是对的，才是令我满意的，却也没想过或许根本就没有答案<br>时常在即将睡着，意识远去的一瞬间惊醒，想着或许这就是死前的感受吧，庆幸只是梦，还不是时候，再继续尝试睡眠。<br>我一直觉得自己是归流中的一员，我害怕的也只是太过突然的死亡，让我没时间好好告个别，总结自己的一生，然后问自己一句“这是一段令你满意的旅途吗”<br>我一直太过于担忧未来，却也没活在当下才是问题所在吧。</p><hr><p>上一个公司的老板来问我去上海了没，没去的话问我想不想回去。<br>广州过了的游戏公司因为我打算去上海的那家被我推了，<br>因为疫情没能去的上海的那家也就结束了，<br>留在昆明继续从事一样的工作，只是用的接触的技术更靠近时代，可以稍微多应用一点学到的知识。<br>那我该怎么和他说呢，我打算再工作学习两年，去看看有没有机会能不能做想做的事。<br>工作、学习、不愿放弃的游戏，我活的太认真太累了，我觉得我做的都是对的，但是又没从这样的生活里获得什么快乐，<br>而且还越来越觉得自己实在太无用…技艺不好，也不会生活，也不和人交往，没什么追求<br>我到底想要什么，我想做什么<br>今天也是和焦虑抗争的一天<br>自己和自己的战争永不停息(</p><hr><p>放空大脑继续按这个样子活下去，这不也是一种躺平</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1051.高度检查器</title>
    <link href="/2022/06/13/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
    <url>/2022/06/13/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。</p><p>排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。</p><p>给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。</p><p>返回满足 heights[i] != expected[i] 的 下标数量 。</p><p> </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<br>高度：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>预期：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>下标 <span class="hljs-number">2</span> 、<span class="hljs-number">4</span> 、<span class="hljs-number">5</span> 处的学生高度不匹配。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：<br>高度：[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>预期：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>所有下标的对应学生高度都不匹配。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/height-checker">https://leetcode.cn/problems/height-checker</a></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>读完题目第一反应当然就是copy一个数组之后进行排序，然后再依次对比每一位上的数对不对。<br>这样做的时间复杂度是O(NlogN)<br>不过实际上不需要进行比较排序，因为这题的整数范围非常小可以先建立一个长度为数组最大值的统计数组，记录下每个数字出现了多少次。<br>然后再循环取出统计数组里的值和原数组一一比对就行，时间复杂度是O(n + k) k是整数的范围。<br>所以能看出来计数排序是用空间换时间，当范围太大的时候就不适合了，具体就是当k大于NlogN的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">heightChecker</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height : heights) &#123;<br>            count[height]++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (count[i]-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (heights[j++] != i) result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/2022/06/07/CompletableFuture/"/>
    <url>/2022/06/07/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><blockquote><p>之前juc一直是看书学，对，就java并发编程的艺术，看完之后不仅很长时间没用上，而且后来才知道它是基于jdk1.7写的，<br>在1.8版本不仅多了completableFuture,ConcurrentHashMap的结构也发生改变等等…<br>于是现在继续补坑</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java8中,CompletableFuture提供了非常强大的Future的扩展功能,可以帮助我们简化异步编程的复杂性,<br>并且提供了函数式编程的能力,可以通过回调的方式处理计算结果,也提供了转换和组合CompletableFuture的方法，<br>支持在完成之后触发一些函数或执行一些操作。<br>    主要实现了Future接口和completionStage接口。<br>    completionStage表示异步操作中的某个阶段，一个阶段完成后可以执行另一个阶段，每个阶段可以执行不同的操作，<br>如thenAccept、thenRun、thenApply</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol><li>提供了四个静态方法来创建</li><li>runAsync方法不支持返回值、supplyAsync方法可以支持返回值</li><li>如果不传入executor会用ForkJoinPool.commonPool()作为它的线程池执行异步代码。如果指定线程池,则使用指定的线程池运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//runAsync方法不支持返回值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br><span class="hljs-comment">//supplyAsync可以支持返回值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p>和future不同，不需要创建线程再启动，源码中创建对象之后会直接提交启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                                 Supplier&lt;U&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><ol><li>get( ) 只要调用了get( )方法,不管是否计算完成都会导致阻塞(会抛出异常)</li><li>get(long timeout, TimeUnit unit) 输入一个等待时间，超时后会继续向下运行</li><li>getNow(T valuelfAbsent) 没有计算完成的情况下,返回一个替代结果。计算完成的话返回计算完成后的结果</li><li>join( ) join方法和get( )方法作用一样,不同的是,join方法不会抛出异常</li></ol><h3 id="对结果进行处理"><a href="#对结果进行处理" class="headerlink" title="对结果进行处理"></a>对结果进行处理</h3><ol><li>handle<br>当上一个阶段正常或者异常完成的时候会调用handle中定义的方法进行运算，并将运算结果或者异常作为参数传递给下一个阶段，<br>因此就算在执行中出现异常并不会中止执行，而是会继续向下传递。<ol><li>handle 用当前的线程继续执行</li><li>handleAsync 不添加线程池参数，用默认的线程池(ForkJoinPool.commonPool())重新开一个线程执行；提供参数，用指定的线程池执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2L</span>,TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2L</span>,TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool2-&quot;</span>));<br>        <br>        CompletableFuture.supplyAsync(() -&gt;&#123;<br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;,executor1).handle((f,e) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;222&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>        &#125;).handleAsync((f,e) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;333&quot;</span>);<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">3</span>;<br>        &#125;, executor2).whenComplete((v,e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----计算结果： &quot;</span>+v);<br>        &#125;<br>        &#125;).exceptionally(e -&gt; &#123;<br>        e.printStackTrace();<br>        System.out.println(e.getMessage());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;----主线程先去忙其它任务&quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>执行结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">main----主线程先去忙其它任务<br><span class="hljs-number">111</span><br>clear-cache-pool1-<span class="hljs-number">1</span><br><span class="hljs-number">222</span><br>clear-cache-pool1-<span class="hljs-number">1</span><br><span class="hljs-number">333</span><br>clear-cache-pool2-<span class="hljs-number">1</span><br>----计算结果： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li></ol></li><li>whenComplete<br> 上一步执行完成之后对结果value或者异常exception进行处理，没有返回值，并将v和e继续向下一步传递，类似于finally<ol><li>whenComplete</li><li>whenCompleteAsync 同上，交给线程池去执行</li></ol></li><li>exceptionally<br> 上一步结束如果出现异常则执行这一步的处理，可以有返回值,返回值类型需要和上一个消费性操作相同(handle、apply),<br>如thenRun的返回类型是Void，那么exceptionally的返回类型也为Void<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool2-&quot;</span>));<br>        CompletableFuture&lt;Integer&gt; exceptionally = CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;, executor1).handle((f, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;222&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>        &#125;).handleAsync((f, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;333&quot;</span>);<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> f + <span class="hljs-number">3</span>;<br>        &#125;, executor2).whenComplete((v, e) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;计算结果： &quot;</span> + v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;出异常了&quot;</span> + v);<br>            &#125;<br>        &#125;).whenComplete((v, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第二个whenComplete的v:&quot;</span> + v);<br>            System.out.println(<span class="hljs-string">&quot;第二个whenComplete的e:&quot;</span> + e);<br>        &#125;).exceptionally(e -&gt; &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;第一个exceptionally:&quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125;).whenComplete((v, e) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第三个whenComplete的v:&quot;</span> + v);<br>            System.out.println(<span class="hljs-string">&quot;第三个whenComplete的e:&quot;</span> + e);<br>        &#125;).exceptionally(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;第二个exceptionally:&quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;最终结果&quot;</span> + exceptionally.join());<br>        executor1.shutdown();<br>        executor2.shutdown();<br>    &#125;<br>执行结果：<br>        <span class="hljs-number">111</span><br>        clear-cache-pool1-<span class="hljs-number">1</span><br>        <span class="hljs-number">222</span><br>        clear-cache-pool1-<span class="hljs-number">1</span><br>        <span class="hljs-number">333</span><br>        clear-cache-pool2-<span class="hljs-number">1</span><br>        出异常了<span class="hljs-literal">null</span><br>        第二个whenComplete的v:<span class="hljs-literal">null</span><br>        第二个whenComplete的e:java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero<br>        第一个exceptionally:java.lang.ArithmeticException: / by zero<br>        第三个whenComplete的v:<span class="hljs-number">10</span><br>        第三个whenComplete的e:<span class="hljs-literal">null</span><br>        最终结果<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h3></li><li>thenRun 开启一个新的任务，不需要参数也没有返回值</li><li>thenAccept 需要一个参数，但是没有返回值 (返回一个Void)</li><li>thenApply 需要一个参数，有一个返回值 (返回一个Void)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThreadFactory</span>(<span class="hljs-string">&quot;clear-cache-pool1-&quot;</span>));<br>        <span class="hljs-type">Void</span> <span class="hljs-variable">exceptionally</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;, executor1)<br>                .thenApply(f -&gt; f + <span class="hljs-number">2</span>)<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;apply的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;apply的异常:&quot;</span> + e);<br>                &#125;)<br>                .thenAccept((v) -&gt; System.out.println(<span class="hljs-string">&quot;accept:&quot;</span> + v))<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;accept的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;accept的异常:&quot;</span> + e);<br>                &#125;)<br>                .thenRun(() -&gt; System.out.println(<span class="hljs-string">&quot;run:&quot;</span> + Thread.currentThread().getName()))<br>                .whenComplete((v, e) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;run的结果:&quot;</span> + v);<br>                    System.out.println(<span class="hljs-string">&quot;run的异常:&quot;</span> + e);<br>                &#125;).join();<br>        System.out.println(exceptionally);<br>        executor1.shutdown();<br>    &#125;<br>执行结果：<br>        <span class="hljs-number">111</span><br>        apply的结果:<span class="hljs-number">3</span><br>        apply的异常:<span class="hljs-literal">null</span><br>        accept:<span class="hljs-number">3</span><br>        accept的结果:<span class="hljs-literal">null</span><br>        accept的异常:<span class="hljs-literal">null</span><br>        run:clear-cache-pool1-<span class="hljs-number">1</span><br>        run的结果:<span class="hljs-literal">null</span><br>        run的异常:<span class="hljs-literal">null</span><br>        <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h3></li><li>applyToEither:两个任务只要有一个执行完成,获取它的返回值,处理任务并有新的返回值</li><li>acceptEither:两个任务只要有一个执行完成,获取它的返回值,处理任务,没有新的返回值</li><li>runAfterEither:两个任务只要有一个执行完成,不需要参数,处理任务,也没有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEither</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">applyToEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="hljs-built_in">super</span> T, U&gt; fn,</span><br><span class="hljs-params">        Executor executor)</span><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEither</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action,</span><br><span class="hljs-params">    Executor executor)</span><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEither</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span><br>                                                  <br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span>   <br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                       Runnable action,</span><br><span class="hljs-params">                                                       Executor executor)</span><br></code></pre></td></tr></table></figure><h3 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h3>两个任务都完成之后进行下一步操作</li><li>thenCombine 两个参数，有返回值</li><li>thenAcceptBoth 两个参数，无返回值</li><li>runAfterBoth 不需要参数也没有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombine</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span><br><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombineAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span><br> <span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombineAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn, Executor executor)</span><br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBoth</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBothAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action)</span> <br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptBothAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">        CompletionStage&lt;? extends U&gt; other,</span><br><span class="hljs-params">        BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; action, Executor executor)</span>      <br><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBoth</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                Runnable action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                     Runnable action)</span>  <br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,</span><br><span class="hljs-params">                                                     Runnable action,</span><br><span class="hljs-params">                                                     Executor executor)</span><br></code></pre></td></tr></table></figure><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3>两个都是静态方法</li><li>allOf 等待所有任务完成，无返回值</li><li>anyOf 只要有一个任务完成，返回该任务的返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">allOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;<br>    <span class="hljs-keyword">return</span> andTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">anyOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;<br>    <span class="hljs-keyword">return</span> orTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><p>初步施工完成，待未来补充</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>875.爱吃香蕉的珂珂</title>
    <link href="/2022/06/07/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <url>/2022/06/07/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p><p> </p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输出：<span class="hljs-number">4</span><br>输入：piles = [<span class="hljs-number">3,6,7,11</span>], h = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：piles = <span class="hljs-string">[30,11,23,4,20]</span>, h = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/koko-eating-bananas">https://leetcode.cn/problems/koko-eating-bananas</a></p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : piles) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; max) max = i;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (sum / h), r = max;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(piles, mid, h)) &#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : piles) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">1.0</span> / m;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i / m;<br>            ans += b &lt; a ? b + <span class="hljs-number">1</span> : b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt;= h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>选定一个吃香蕉的速度，高于这个速度，一定能吃完，低于这个速度一定吃不完。<br>于是可以用二分求出这个值是多少</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记20220606</title>
    <link href="/2022/06/06/%E6%97%A5%E8%AE%B020220606/"/>
    <url>/2022/06/06/%E6%97%A5%E8%AE%B020220606/</url>
    
    <content type="html"><![CDATA[<p>因为工作，从九点上班就一直肝代码到五点半，中间完全没摸鱼，并且感觉时间飞速，极度充实的这种感觉，真的是久违了。<br>（然后突然出了个bug加班到七点）<br>我的焦虑大概是没能治好，自卑到今天早上进电梯就一直在想着能不能完成任务，整个人心悸胃疼，想着撒腿就跑回家蒙被子里。<br>每次都是事后去回想其实也没什么大不了的事。所以现在的心情其实还算很平静。</p><p>sai2和procreate格式上可以互转,感觉可以在家用sai出门用procreate（</p><p>想做的事很多，时间真的很少，所以我得主动放弃很多东西才行</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>929. 独特的电子邮件地址</title>
    <link href="/2022/06/05/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/06/05/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 ‘@’ 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 ‘.’ 或 ‘+’ 。</p><p>例如，在 <a href="mailto:&#x61;&#108;&#x69;&#x63;&#x65;&#64;&#x6c;&#x65;&#101;&#x74;&#99;&#111;&#x64;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#108;&#x69;&#x63;&#x65;&#64;&#x6c;&#x65;&#101;&#x74;&#99;&#111;&#x64;&#x65;&#46;&#x63;&#x6f;&#x6d;</a>中， alice 是 本地名 ，而 leetcode.com 是 域名 。<br>如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（’.’），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。</p><p>例如，”<a href="mailto:&#97;&#x6c;&#105;&#x63;&#101;&#46;&#122;&#x40;&#x6c;&#101;&#101;&#x74;&#x63;&#x6f;&#100;&#101;&#46;&#99;&#111;&#x6d;">&#97;&#x6c;&#105;&#x63;&#101;&#46;&#122;&#x40;&#x6c;&#101;&#101;&#x74;&#x63;&#x6f;&#100;&#101;&#46;&#99;&#111;&#x6d;</a>” 和 “<a href="mailto:&#97;&#x6c;&#105;&#x63;&#x65;&#x7a;&#x40;&#x6c;&#x65;&#x65;&#116;&#x63;&#x6f;&#x64;&#101;&#x2e;&#x63;&#111;&#x6d;">&#97;&#x6c;&#105;&#x63;&#x65;&#x7a;&#x40;&#x6c;&#x65;&#x65;&#116;&#x63;&#x6f;&#x64;&#101;&#x2e;&#x63;&#111;&#x6d;</a>” 会转发到同一电子邮件地址。<br>如果在 本地名 中添加加号（’+’），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。</p><p>例如 <a href="mailto:&#x6d;&#x2e;&#121;&#x2b;&#110;&#97;&#x6d;&#101;&#64;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;">&#x6d;&#x2e;&#121;&#x2b;&#110;&#97;&#x6d;&#101;&#64;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;</a> 将转发到 <a href="mailto:&#109;&#x79;&#x40;&#101;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#109;&#x79;&#x40;&#101;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a>。<br>可以同时使用这两个规则。</p><p>给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p><p>示例 1：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：emails = [<span class="hljs-string">&quot;test.email+alex@leetcode.com&quot;</span>,<span class="hljs-string">&quot;test.e.mail+bob.cathy@leetcode.com&quot;</span>,<span class="hljs-string">&quot;testemail+david@lee.tcode.com&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：实际收到邮件的是 <span class="hljs-string">&quot;testemail@leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;testemail@lee.tcode.com&quot;</span>。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/unique-email-addresses">https://leetcode.cn/problems/unique-email-addresses</a></p><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numUniqueEmails</span><span class="hljs-params">(String[] emails)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : emails) &#123;<br>            String[] ss = s.split(<span class="hljs-string">&quot;@&quot;</span>);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : ss[<span class="hljs-number">0</span>].toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">break</span>;<br>                builder.append(c);<br>            &#125;<br>            set.add(builder + <span class="hljs-string">&quot;@&quot;</span> +ss[<span class="hljs-number">1</span>]);<br>        &#125; <br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是很简单的模拟题</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>473. 火柴拼正方形</title>
    <link href="/2022/06/01/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/06/01/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: matchsticks = [1,1,2,2,2]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 能拼成一个边长为2的正方形，每边两根火柴。</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/matchsticks-to-square">https://leetcode.cn/problems/matchsticks-to-square</a></p><h1 id="回溯法-dfs"><a href="#回溯法-dfs" class="headerlink" title="回溯法-dfs"></a>回溯法-dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">makesquare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] matchsticks)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLen</span> <span class="hljs-operator">=</span> Arrays.stream(matchsticks).sum();<br>        <span class="hljs-keyword">if</span> (totalLen % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Arrays.sort(matchsticks);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matchsticks.length - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matchsticks[i];<br>            matchsticks[i] = matchsticks[j];<br>            matchsticks[j] = temp;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, matchsticks, edges, totalLen / <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] matchsticks, <span class="hljs-type">int</span>[] edges, <span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;<br>            edges[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (edges[i] &lt;= len &amp;&amp; dfs(index + <span class="hljs-number">1</span>, matchsticks, edges, len)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            edges[i] -= matchsticks[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、先求出所有火柴的长度总和，如果总和模4不为0则直接返回<br>2、对火柴长度从大到小排序（这一步是为了在dfs的时候降低时间消耗）<br>3、数组edges记录四个边的当前长度，然后依次把每一根火柴放入一个边进行尝试，失败就回溯状态换下一条边， 找到一个能恰好全部放下的结果<br>因为有四条边，每根火柴都要尝试四次，所以每新增一根火柴就要乘上四次。<br>时间复杂度O(4^n)</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>中等</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 114. 外星文字典</title>
    <link href="/2022/05/31/%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8/"/>
    <url>/2022/05/31/%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p><p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p><p>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p><p>示例 1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;wrt&quot;</span>,<span class="hljs-string">&quot;wrf&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;ett&quot;</span>,<span class="hljs-string">&quot;rftt&quot;</span>]<br>输出：<span class="hljs-string">&quot;wertf&quot;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>]<br>输出：<span class="hljs-string">&quot;zx&quot;</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：不存在合法字母顺序，因此返回 <span class="hljs-string">&quot;&quot;</span> 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/Jf1JuT">https://leetcode.cn/problems/Jf1JuT</a></p><h1 id="建图-拓扑排序-bfs"><a href="#建图-拓扑排序-bfs" class="headerlink" title="建图+拓扑排序+bfs"></a>建图+拓扑排序+bfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>            Map&lt;Character, Set&lt;Character&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">26</span>); <span class="hljs-comment">// 指向</span><br>            <span class="hljs-type">int</span>[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 入度</span><br>            Set&lt;Character&gt; countSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// 出现过的字母</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> words.length;<br>            Arrays.fill(in, -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 构建图</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-comment">// 统计所有出现过的字母</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : words[i].toCharArray()) &#123;<br>                    countSet.add(c);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 统计各字母的入度</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">char</span>[] chars1 = words[i - <span class="hljs-number">1</span>].toCharArray();<br>                    <span class="hljs-type">char</span>[] chars2 = words[i].toCharArray();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">clen</span> <span class="hljs-operator">=</span> Math.min(chars1.length, chars2.length);<br>                    <span class="hljs-keyword">while</span> (index &lt; clen &amp;&amp; chars1[index] == chars2[index]) index++;<br>                    <span class="hljs-keyword">if</span> (index == clen)&#123;<br>                        <span class="hljs-keyword">if</span> (chars1.length &gt; clen) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    build(map, chars1[index], chars2[index], in);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//bfs</span><br>            Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>                <span class="hljs-comment">// 出现过，并且入度为0的字母全都加入队列</span><br>                <span class="hljs-keyword">if</span> (countSet.contains((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + i)) &amp;&amp; in[i] &lt; <span class="hljs-number">1</span>)&#123;<br>                    deque.addLast((<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;a&#x27;</span>));<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>                <span class="hljs-comment">// 把队列首部的字母全都组装起来，并且它所到达的字母入度减一，</span><br>                <span class="hljs-comment">// 把所有入度为0的字母再加到队列尾部</span><br>                <span class="hljs-type">Character</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>                builder.append(c1);<br>                Set&lt;Character&gt; set = map.getOrDefault(c1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : set)&#123;<br>                    in[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (in[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) deque.addLast(c);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> builder.length() == countSet.size() ? builder.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 建立c1-&gt;c2的单向边</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(Map&lt;Character, Set&lt;Character&gt;&gt; map, <span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2, <span class="hljs-type">int</span>[] in)</span> &#123;<br>            <span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-keyword">return</span>;<br>            Set&lt;Character&gt; c1Set = map.getOrDefault(c1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            <span class="hljs-keyword">if</span> (!c1Set.contains(c2))&#123;<br>                c1Set.add(c2);<br>                <span class="hljs-keyword">if</span> (in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">0</span>;<br>                in[c2 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map.put(c1, c1Set);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>主要知识点是拓扑排序，还是很容易理解的。<br>贴一下有图解的博客链接：<br><a href="https://blog.csdn.net/chenweiye1/article/details/113563417">https://blog.csdn.net/chenweiye1/article/details/113563417</a><br>题目里的坑主要集中于以下几个用例：<br>[“x”, “x”]: “x”<br>[“xy”, “x”]: “”<br>[“x”, “xy”]: “xy”</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>广度优先搜索</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1022.从根到叶的二进制数之和</title>
    <link href="/2022/05/30/%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/05/30/%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><p>例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers">https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers</a></p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRootToLeaf</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>            dfs(root, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> i)</span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>            i = (i &lt;&lt; <span class="hljs-number">1</span>) ^ root.val;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                result += i;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            dfs(root.left, i);<br>            dfs(root.right, i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单题</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>力扣每日一题</category>
      
      <category>简单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面各种初始化学习</title>
    <link href="/2022/05/27/%E9%A1%B5%E9%9D%A2%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/27/%E9%A1%B5%E9%9D%A2%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化第一篇文章</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
